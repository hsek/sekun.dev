[{"content":"So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.\n Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:\n \u0026ldquo;Thanks, I hate it.\u0026rdquo; \u0026ndash; Pay08, 2022\n  \u0026ldquo;downvoted for being a menace to society.\u0026rdquo; \u0026ndash; MultiplyAccumulate, 2022\n  \u0026ldquo;blursed \u0026quot; \u0026ndash; Jaxius3\n  \u0026ldquo;‚ÄúMade with regret.‚Äù Hahahaha. Excellent.\u0026rdquo; \u0026ndash; IronWhiskers, 2022\n  \u0026ldquo;What is wrong with you?\u0026rdquo; \u0026ndash; Jeff\n   That\u0026rsquo;s a lot of people disgusted by what I made\n  Here are some of the things I learned from building a simple project.\nTech Stack After looking around, I decided to go with the following:\n axum (web server) maud (HTML templates via Rust macros) postgres (persistent data storage and business logic) sqitch (database schema migration tool) typescript (you know what this is) docker (\u0026ldquo;simple\u0026rdquo; deploys) nix (reproducible environments)  PostgreSQL Procedures Procedures are extremely cool although this isn\u0026rsquo;t exactly new to me. I\u0026rsquo;ve been experimenting with this in one of my previous, unfinished projects called GNAWEX 1 (One day I will finish it don\u0026rsquo;t you worry).\nThis allows you to implement some business logic in SQL, without having to implement it in the application level. If ever PostgreSQL is a constant in your project, and intend to rewrite the app from scratch, you might just end up having to rewrite the glue rather than your business logic. emojied isn\u0026rsquo;t doing anything too exciting though, so I can\u0026rsquo;t really demonstrate all that is cool about it.\nOkay, an example would be fetching a URL given an identifier, and incrementing the clicks column by one. Here\u0026rsquo;s an example of a procedure that does exactly that:\nCREATE FUNCTION app.get_url(query TEXT) -- ^ This contains the emoji sequence `identifier`  RETURNS TEXT LANGUAGE sql AS $$ -- Considered as a \u0026#34;clicked\u0026#34; link whenever this gets triggered  UPDATE app.links SET clicks = clicks + 1 WHERE links.identifier = $1; -- Builds the URL so that I don\u0026#39;t have to do this in the web server  SELECT concat(scheme, \u0026#39;://\u0026#39;, hosts.name, path) AS url FROM app.links JOIN app.hosts ON links.host = hosts.host_id WHERE links.identifier = $1; $$; It\u0026rsquo;s a simple function that uses SQL as the language that expects any TEXT, and returns a TEXT as well, which is a sequence of emojis, and the URL it maps to respectively. Since whatever happens in this procedure is in the same transaction as what called it, e.g (SELECT * FROM app.get_url('üçäüåê')), if any of this fails, then it rolls back everything, including the incrementing of clicks. If this was at the application level, I\u0026rsquo;d have to reach for whatever transaction implementation it uses (like Ecto.Multi) which doesn\u0026rsquo;t make sense in this case cause Postgres already natively supports transactions.\nI try to make heavy use of stored procedures as long as it\u0026rsquo;s applicable. Inserting to multiple tables with one function, fetching leaderboard entries, etc.\nError handling with implicit From\u0026lt;T\u0026gt; Error handling is pretty nice with Rust, especially since I was never a fan of exceptions since it made control flow so weird. Although that may be because I never really invested that much time working with them. In Rust, I like that you can do two things for errors: errors encoded as ADTs, or panic (unrecoverable). Although I\u0026rsquo;m not entirely sure if all errors can be encoded in sum types, and what can be done if ever one needs to recover from a panic. But for emojied, I definitely don\u0026rsquo;t have to think about that.\nWhat I did have to deal with was finding a more convenient way when dealing with other Error types. For instance, there\u0026rsquo;s tokio_postgres::Error, then there\u0026rsquo;s env::VarError, and if I need to bubble up these errors to the binary, I\u0026rsquo;m gonna need a convenient enough way to do that otherwise I\u0026rsquo;m gonna have a difficult time.\nLet\u0026rsquo;s say I have two errors, a database one, and an application one.\nenum AppError { Foo, Baz } enum DbError { FailedToConnect, InvalidTLSCert } fn some_db_action() -\u0026gt; Result\u0026lt;String, DbError\u0026gt; { Err(DbError::FailedToConnect) } fn some_app_action() -\u0026gt; Result\u0026lt;String, AppError\u0026gt; { let result1 = some_db_action()?; let result2 = some_db_action()?; Ok(result1) } This fails to compile, here\u0026rsquo;s what rustc says:\nerror[E0277]: `?` couldn't convert the error to `AppError` | 212 | fn app_action() -\u0026gt; Result\u0026lt;String, AppError\u0026gt; { | ------------------------ expected `AppError` because of this 213 | let result1 = db_action()?; 214 | let result2 = db_action()?; | ^ the trait `From\u0026lt;url::DbError\u0026gt;` is not implemented for `AppError` | = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `Fro m` trait = note: required because of the requirements on the impl of `FromResidual\u0026lt;Result\u0026lt;Infallible, url::DbError\u0026gt;\u0026gt;` for `Result\u0026lt;std::string::String, AppError\u0026gt;` For more information about this error, try `rustc --explain E0277`. So it tells me that using ? implicitly converts DbError to AppError via the From trait. And because I do not have a trait instance like impl From\u0026lt;DbError\u0026gt; for AppError, it fails.\nAnother thing is I somehow need to bubble up DbError up to the application error somehow. The method I ended up using is to just add a field to the AppError record. It\u0026rsquo;s a bit tiring to copy all the DbError variants over to the AppError enum. I mean, it\u0026rsquo;s fine for this one since it doesn\u0026rsquo;t have that many, but it becomes.\nenum AppError { DbError(DbError), // Hooray!  Foo, Baz } And then I can create a From\u0026lt;DbError\u0026gt; instance:\nimpl From\u0026lt;DbError\u0026gt; for AppError { fn from(e: DbError) -\u0026gt; Self { AppError::DbError(e) } } Which compiles!\nIf I wanted to avoid From, I could do this:\nlet result1 = db_action().map_err(|_| AppError::Foo)?; Except it\u0026rsquo;s kinda annoying cause I have to do this at every call site. Although there are times when I did end up using this.\nApplication configuration While convenient, I can\u0026rsquo;t just hard-code everything into the application, especially for a public project. There are a lot of sensitive data like certs, and sometimes it\u0026rsquo;s just more convenient for whoever is using the application to change stuff without touching the source code. In my case, I had to make it flexible enough to change database credentials.\n A common way to do it is through environment variables.\ne.g PG__HOST=\u0026quot;db.example.com\u0026quot; emojied. So whenever I need to update stuff, all I have to do is just change the environment variable, and I\u0026rsquo;m spared from touching the source code!\n Here\u0026rsquo;s emojied\u0026rsquo;s config for it to run:\npub struct AppConfig { /// Application host  pub host: String, /// PostgreSQL config  pub pg: tokio_postgres::Config, /// Pool manager config  pub manager: ManagerConfig, /// Pool size  pub pool_size: usize, pub ca_cert_path: Option\u0026lt;String\u0026gt;, } Then I created an associated function for it called from_env/0 which returns a Result\u0026lt;AppConfig, Error\u0026gt;. I\u0026rsquo;ll talk about the Error part in the Error Handling section. Then I can use Rust\u0026rsquo;s std::env module to get a var\u0026rsquo;s value!\nHere\u0026rsquo;s a tiny example:\nuse std::env; struct AppConfig { pg_host: String, } impl AppConfig { fn from_env() -\u0026gt; Result\u0026lt;AppConfig, Error\u0026gt; { let host = env::var(\u0026#34;PG__HOST\u0026#34;)?; Ok(AppConfig { pg_host: host }) } }  Side note: This kinda looks monadic, where it binds AppConfig to host, and evaluates to Error and \u0026ldquo;exits\u0026rdquo; otherwise.\n Handling database\u0026hellip;handler in axum I created this database handle that has all the things I need to communicate with the database server:\npub struct Handle { pub pool: Pool, } It\u0026rsquo;s pretty simple. It\u0026rsquo;s a struct that has a pool field. Then I created two more functions to make things more convenient: new/1, and client/1.\nnew(config: AppConfig) -\u0026gt; Result\u0026lt;Handle, Error\u0026gt; expects an AppConfig as an argument, and if all goes well, then a new database handle with all the important things in it. client(\u0026amp;self) -\u0026gt; Result\u0026lt;Pool, Error\u0026gt; expects a reference to self, which is Handle in this case. This uses the DB pool to create a new client. From this client, you can do DB queries with it.\n// Grabs a client from the pool let client = handle.client().await?; // Runs a query that gets a URL\u0026#39;s stats let data = client .query(\u0026#34;SELECT * FROM app.get_url_stats($1)\u0026#34;, \u0026amp;[\u0026amp;identifier]) .await?; // Manually maps the row to a leaderboard entry let db_id = data[0].try_get(0)?; let db_clicks = data[0].try_get(1)?; let db_url = data[0].try_get(2)?; Ok(leaderboard::Entry { identifier: db_id, clicks: db_clicks, url: db_url, }) Okay, so I somehow need access to the database handle in the \u0026ldquo;controllers\u0026rdquo;, like in controllers::leaderboard.\n I\u0026rsquo;m only calling it a controller since it\u0026rsquo;s a common concept. axum doesn\u0026rsquo;t call it that.\n let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)); axum recommends 2 mentions that you could use \u0026ldquo;request extensions\u0026rdquo; which looks like it acts like middleware. It recommends to have Arc inhabit Extension (Extension\u0026lt;Arc\u0026lt;T\u0026gt;\u0026gt;), but why?\nTime to do it in some wrong ways. This is fine since rustc is quite helpful with its error messages.\nI\u0026rsquo;ll try to move handle instead:\nuse axum::{extract::Extension, routing::get, Router}; use std::net::SocketAddr; pub async fn run(handle: db::Handle) -\u0026gt; Result\u0026lt;(), hyper::Error\u0026gt; { let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await } Doing that gives me this error:\nerror[E0277]: the trait bound `db::Handle: Clone` is not satisfied --\u0026gt; src/lib.rs:36:16 | 36 | .layer(Extension(handle)); | ----- ^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `db::Handle` | | | required by a bound introduced by this call | = note: required because of the requirements on the impl of `tower_layer::Layer\u0026lt;Route\u0026lt;_\u0026gt;\u0026gt;` for `Extension\u0026lt;db:: Handle\u0026gt;` For more information about this error, try `rustc --explain E0277`. It seems like I need to derive Clone for db::Handle since it probably gets cloned every time, although I\u0026rsquo;m not sure exactly when it does get cloned. In every new request?\nSo what happens if I do derive Clone?\n#[derive(Clone)] struct Handle { pub pool: Pool } Then I need to make sure that the function\u0026rsquo;s type signature matches:\npub async fn leaderboard( Extension(handle): Extension\u0026lt;db::Handle\u0026gt; // ^ Here! axum seems to know exactly where to apply it to the args. Not sure  // how this is done (yet). ) -\u0026gt; (StatusCode, Markup) { match leaderboard::fetch(\u0026amp;handle).await { Ok(entries) =\u0026gt; { (StatusCode::OK, views::leaderboard::render(entries)) }, Err(_e) =\u0026gt; (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}), } } Well, it seems to compile just fine. The leaderboard page works fine as well. I don\u0026rsquo;t really have that much experience with this yet but my current assumption is that I\u0026rsquo;m required to derive Clone for Handle since there\u0026rsquo;s no way to do shared ownership. So what it does is that it ends up cloning it every time. But, what if I don\u0026rsquo;t want to clone it? What if I just pass around references?\npub async fn run(handle: db::Handle) -\u0026gt; Result\u0026lt;(), hyper::Error\u0026gt; { let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(\u0026amp;handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await Compiles with this helpful error message:\nerror[E0597]: `handle` does not live long enough --\u0026gt; src/lib.rs:36:26 | 22 | let app = Router::new() | _______________- 23 | | .route(\u0026quot;/leaderboard\u0026quot;, routing::get(controllers::leaderboard)) 24 | | .layer(Extension(\u0026amp;handle)); | |__________________________^^^^^^^_- argument requires that `handle` is borrowed for `'static` | | | borrowed value does not live long enough ... 44 | } | - `handle` dropped here while still borrowed For more information about this error, try `rustc --explain E0597`. Unfortunately, I\u0026rsquo;m not too familiar with how lifetimes work in async/await. But it looks like since it\u0026rsquo;s non-blocking, handle gets dropped since the function reaches the end of its scope while the server is still running.\n This is all just somewhat smart guessing though. I\u0026rsquo;m gonna need to do more reading on this topic.\n Wait, what about app then? Won\u0026rsquo;t this get dropped as well? I wanted to confirm if this did get moved, or if it did some other trickery I had no idea about:\nlet app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(handle)); let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); let foo = axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await; println!(\u0026#34;{:?}\u0026#34;, app); foo So if app does get moved, then rustc should complain about me accessing a variable with no ownership; which it does:\nerror[E0382]: borrow of moved value: `app` --\u0026gt; src/lib.rs:46:22 | 22 | let app = Router::new() | --- move occurs because `app` has type `Router`, which does not implement the `Copy` trait ... 42 | .serve(app.into_make_service()) | ------------------- `app` moved due to this method call ... 46 | println!(\u0026#34;{:?}\u0026#34;, app); | ^^^ value borrowed here after move | note: this function takes ownership of the receiver `self`, which moves `app` Phew! It\u0026rsquo;s almost like I\u0026rsquo;m encouraged to try out all the failed scenarios to learn a lot of things since the compiler is quite helpful.\nOkay, since I didn\u0026rsquo;t want this to get cloned all the time, I will just follow what axum used in its examples - the usage of Arc\u0026lt;T\u0026gt;:\npub async fn run(handle: db::Handle) -\u0026gt; Result\u0026lt;(), hyper::Error\u0026gt; { let handle = Arc::new(handle); // ^ Shadow previous binding with `Arc\u0026lt;db::Handle\u0026gt;`  let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await } And then I\u0026rsquo;ll remove the Clone derivation:\npub struct Handle { pub pool: Pool, } So if I\u0026rsquo;m not mistaken, which I probably am, Arc\u0026lt;T\u0026gt; should allow me to share ownership of db::Handle without having to clone it 3.\npub async fn leaderboard( Extension(handle): Extension\u0026lt;Arc\u0026lt;db::Handle\u0026gt;\u0026gt; ) -\u0026gt; (StatusCode, Markup) { match leaderboard::fetch(\u0026amp;*handle).await { Ok(entries) =\u0026gt; { (StatusCode::OK, views::leaderboard::render(entries)) }, Err(_e) =\u0026gt; (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}), } } Then in leaderboard::fetch/1:\npub async fn fetch_url( handle: \u0026amp;db::Handle, identifier: String ) -\u0026gt; Result\u0026lt;String, Error\u0026gt; { let client = handle.client().await?; let row = client .query_one(\u0026#34;SELECT app.get_url($1)\u0026#34;, \u0026amp;[\u0026amp;identifier]) .await?; row.try_get(0).map_err(|e| Error::from(e)) } Although, I had to manually dereference it to get the reference to Handle. It\u0026rsquo;s also a good thing that I don\u0026rsquo;t have to mutate handle at all because otherwise this would\u0026rsquo;ve been a more painful experience.\nConnecting to a managed database Initially, I used sqlx as the db library since it gets recommended in almost every post about SQL libraries on the Rust subreddit. It worked fine for me until I had to get it to connect to DO\u0026rsquo;s managed DB. It required me to connect to it via TLS, and it wasn\u0026rsquo;t a pleasant experience trying to debug what\u0026rsquo;s wrong with sqlx, so I ditched it settled with tokio-postgres, deadpool-postgres, and native-tls. Oh, I also had a difficult time 4 with rustls since it didn\u0026rsquo;t seem to like DO\u0026rsquo;s CA certificate, which is why I settled with native-tls.\nnative-tls needed OpenSSL setup, which I was able to do with Nix (for the dev environment):\n# ... devShell = pkgs.mkShell { # inherit (self.checks.${system}.pre-commit-check) shellHook; buildInputs = with pkgs; [ # Back-end pkgs.rustc pkgs.cargo pkgs.openssl pkgs.pkg-config ]; PKG_CONFIG_PATH = \u0026#34;${pkgs.openssl.dev}/lib/pkgconfig\u0026#34;; }; # ... So I had to provide the CA cert during runtime, not build-time since: 1) it\u0026rsquo;ll be easier to distribute the static binary and Docker image, and 2) some CA certs are only given during runtime (like DO if ever you\u0026rsquo;re using app platform). This was my process:\n Build static binary \u0026amp; image without CA certs and other DB secrets When the image runs, it\u0026rsquo;s assumed that the necessary environment variables, like one that contains the certificate contents, exist. Write the certificate contents to a file. Run emojied  This seems to be a pretty standard process, although this is fairly tedious.\n// src/config.rs use tokio_postgres::config::SslMode; let mut pg_config = tokio_postgres::Config::new(); // I also read other PG values like hostname, DB name, user, etc. but excluded // those for brevity.  // Not providing CA_CERT is fine let ca_cert_path = match env::var(\u0026#34;PG__CA_CERT\u0026#34;) { Ok(path) =\u0026gt; { // I think `Prefer` is fine as well, which is the default  // for `tokio-postgres`.  pg_config.ssl_mode(SslMode::Require); Some(path) }, Err(_e) =\u0026gt; { None } }; I allowed it to continue running without the cert path in PG__CA_CERT for dev environments.\n// Somewhere in src/db.rs  let manager = match app_config.ca_cert_path { Some(ca_cert_path) =\u0026gt; { // Read file into byte vector  let cert = std::fs::read(ca_cert_path) .map_err(|e| Error::CACertFileError(e))?; // Create a certificate from a PEM file  let ntls_cert = Certificate::from_pem(\u0026amp;cert) .map_err(|_| Error::InvalidCACert)?; let tls = TlsConnector::builder() .add_root_certificate(ntls_cert) .build() .map_err(|_| Error::FailedToBuildTlsConnector)?; let conn = MakeTlsConnector::new(tls); Manager::from_config(app_config.pg, conn, app_config.manager) } None =\u0026gt; Manager::from_config(app_config.pg, NoTls, app_config.manager), }; // Since we need a `manager` to build a pool let pool = Pool::builder(manager) .max_size(app_config.pool_size) .build() .map_err(|_| Error::FailedToBuildPool)?;  The process was quite similar with SQLx but there was something, that I don\u0026rsquo;t really remember anymore, which made it so frustrating to work with.\n Unfortunately, DO doesn\u0026rsquo;t support multiline environment variables, for some reason, so cramming everything including the BEGIN CERTIFICATE and END CERTIFICATE into one line resulted in it getting rejected. So, I just got what\u0026rsquo;s in between, and manually appended it to the file instead.\necho \u0026#34;Dumping CA certificate to /app/ca-certificate.crt\u0026#34; echo \u0026#34;-----BEGIN CERTIFICATE-----\u0026#34; \u0026gt; /app/ca-certificate.crt echo $CA_CERT \u0026gt;\u0026gt; /app/ca-certificate.crt echo \u0026#34;-----END CERTIFICATE-----\u0026#34; \u0026gt;\u0026gt; /app/ca-certificate.crt echo \u0026#34;Executing emojied\u0026#34; ./emojied Kind of hacky, and inconvenient especially if I forget. But it works!\nURL redirect woes This is a short one. For the redirect, I returned an HTTP status 301 5 with a response containing the URL to redirect to. So the process goes something like this:\n Enter https://emojied.net/üçäüåê in the browser. emojied looks for an entry with üçäüåê, and gets the associated URL. Respond with an HTTP 301 and the URL Browser automatically performs the redirect  Unfortunately, and I spent 30mins on this scratching my head why this was happening, the request would get cached, and this is bad! It\u0026rsquo;s bad because I had to increment the clicks column every time the link is visited. But if it\u0026rsquo;s cached, then the server won\u0026rsquo;t bother to call the functions it needs to call!\nThen, I found out that 301 gets cached automatically by the browser 6, and that I needed to use 302.\nHTML templating with maud I had a pleasant experience with server-side templating while I was building a Haskell project called Swoogle. I used lucid 7 which was a pretty darn elegant HTML DSL.\n-- Category options select_ [ id_ \u0026#34;category-options\u0026#34; , name_ \u0026#34;resource\u0026#34; , class_ \u0026#34;bg-white font-semibold dark:bg-su-dark-bg-alt text-su-fg dark:text-su-dark-fg\u0026#34; , required_ \u0026#34;required\u0026#34; ] $ do option_ [disabled_ \u0026#34;disabled\u0026#34;, selected_ \u0026#34;selected\u0026#34;, value_ \u0026#34;\u0026#34;] \u0026#34;Category\u0026#34; option_ [value_ \u0026#34;people\u0026#34;] \u0026#34;People\u0026#34; option_ [value_ \u0026#34;film\u0026#34;] \u0026#34;Film\u0026#34; option_ [value_ \u0026#34;starship\u0026#34;] \u0026#34;Starship\u0026#34; option_ [value_ \u0026#34;vehicle\u0026#34;] \u0026#34;Vehicle\u0026#34; option_ [value_ \u0026#34;species\u0026#34;] \u0026#34;Species\u0026#34; option_ [value_ \u0026#34;planet\u0026#34;] \u0026#34;Planet\u0026#34; Well, I wanted something like that in Rust, and I found maud 8. It\u0026rsquo;s not as \u0026ldquo;nice\u0026rdquo;, and it uses macros pretty heavily. But I don\u0026rsquo;t think I mind it too much. I did run into a problem when I tried to use its latest version with axum since a trait probably wasn\u0026rsquo;t implemented properly, so I had to pull from the main instead:\n[dependencies] ... maud = { git = \u0026quot;https://github.com/lambda-fairy/maud\u0026quot;, branch = \u0026quot;main\u0026quot;, features = [\u0026quot;axum\u0026quot;] } ... So with this, I could do stuff like:\nfn foo() -\u0026gt; Markup { html! { h1 class=\u0026#34;text-red-500\u0026#34; { (\u0026#34;Hello!\u0026#34;) } } } But it doesn\u0026rsquo;t compose as nicely as lucid:\nfn foo(content: Markup) -\u0026gt; Markup { html! { h1 class=\u0026#34;text-red-500\u0026#34; { (\u0026#34;Hello!\u0026#34;) } (content) } } fn bar() -\u0026gt; Markup { let content = html! { h1 class=\u0026#34;text-red-500\u0026#34; { (\u0026#34;Hello, from bar!\u0026#34;) } }; foo(content) } There\u0026rsquo;s a chance that I missed something. Although my copium is: it isn\u0026rsquo;t THAT bad.\n\u0026lt;noscript\u0026gt; tag, and problems with JS toggling extensions I wanted to have the website work with JS disabled because, well, it was a very simple website. There was no reason why I couldn\u0026rsquo;t make all the important features work without JS!\nSo I ended up making heavy use of the \u0026lt;noscript\u0026gt; tag, since it allowed me to display alternative content when the browser has JS disabled. You\u0026rsquo;ll see it littered all over the codebase, like so:\n@match data { RootData::Auto(_) =\u0026gt; { noscript { div class=\u0026#34;w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1\u0026#34; { a href=\u0026#34;?custom_url=t\u0026#34; type=\u0026#34;button\u0026#34; class=\u0026#34;font-medium underline\u0026#34; { \u0026#34;Custom URL\u0026#34; } } } } RootData::Custom(_) =\u0026gt; { noscript { div class=\u0026#34;w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1\u0026#34; { a href=\u0026#34;/\u0026#34; type=\u0026#34;button\u0026#34; class=\u0026#34;font-medium underline\u0026#34; { \u0026#34;Autogenerate a custom URL for me\u0026#34; } } } } } These only get rendered by the browser when JS is disabled. But what do browser extensions like NoScript when it \u0026ldquo;disables\u0026rdquo; JS? It\u0026rsquo;s something like this:\n Block requests for JS files via CSP (Content Security Policies) Replace noscript tags to span or div tags  The problem I ended up with was in #2. Why? Because the noscript tag attributes weren\u0026rsquo;t copied over to the new span/div tags. And that breaks a lot of stuff.\nSo while emojied does work without JS, it won\u0026rsquo;t work due to how the extensions work 9.\nConclusion Alright, that was a lot. I did learn a lot from this experience. I actually only read until chapter 10 of the Rust Book, and skipped to some parts like advanced traits, and other things. I really like the fact that there\u0026rsquo;s a detailed book that talks about some idiomatic Rust patterns, and even the more advanced stuff, that\u0026rsquo;s completely FREE. How crazy is that? My wallet is spared!\nI usually try to avoid failure, even in Haskell, cause its error messages are pretty bad. When I started out, it was pretty much worthless to read GHC\u0026rsquo;s error messages since it would just confuse me even more. It was only until I had people guide me (like justosophy, thank you) that I slowly got to understand what GHC was trying to tell me. With Rust though, it\u0026rsquo;s a completely different experience.\nI like failing because Rust is very helpful with its error messages. In fact, I discover new things by reading it so I\u0026rsquo;m not punished for trying out different things that don\u0026rsquo;t work just to gain more insight.\nI also like that it\u0026rsquo;s fairly easy on resources. I didn\u0026rsquo;t even bother optimizing this at all since I mostly have no idea what I\u0026rsquo;m doing, and I\u0026rsquo;m trying to avoid having to deal with lifetimes as much as possible. I\u0026rsquo;m hosting this on a 1x shared vCPU + 512MB RAM, and it didn\u0026rsquo;t break a sweat during peak load.\nAnyway, so far, so good! I\u0026rsquo;m pretty ecstatic to continue learning Rust.\n  https://github.com/gnawex/gnawex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://docs.rs/axum/0.5.1/axum/#using-request-extensions\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/std/sync/struct.Arc.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://hackage.haskell.org/package/lucid\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/lambda-fairy/maud\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/hackademix/noscript/issues/238\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://blog.sekun.dev/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/","summary":"So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.\n Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:","title":"What I learned from building an emoji URL shortener in Rust"},{"content":"Here\u0026rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn\u0026rsquo;t have the version you want. Fortunately, there\u0026rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?\nNone of em! I don\u0026rsquo;t want to maintain any bash scripts to do that. I just want to load up the Nix environment, and start.\nThat was pretty much what I ran into today, I wanted to have postgrest in my Nix environment so I hopped on nixpkgs search, only to find that the existing versions are quite old, as well as having to build the project from source. Which I didn\u0026rsquo;t want to do due to my limited LTE bandwidth. Why should I? postgrest has pre-built, static binaries in its GitHub releases page. Is there any way I can make use of that instead? And that\u0026rsquo;s what I set off to do today.\ntl;dr: Binaries are built, me copy. Me save mobile data. Happy.\n Disclaimer: I\u0026rsquo;m a Nix newbie.\n Setup I need to import the postgrest flake to an existing flake of another project. The project\u0026rsquo;s directory has a nix folder for all the packages that don\u0026rsquo;t exist in nixpkgs, like so:\nnix ‚îî‚îÄ‚îÄ postgrest ‚îú‚îÄ‚îÄ flake.lock ‚îî‚îÄ‚îÄ flake.nix The flake.lock gets automatically generated by Nix when it finds out that it doesn\u0026rsquo;t exist yet when running nix build; no need to create that. Here\u0026rsquo;s the starting flake.nix:\n{ description = \u0026#34;REST API for any Postgres database\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; }; outputs = {self, nixpkgs}: { }; } A basic flake file has a set of inputs and outputs. The output here will be the postgrest package.\nTime to throw the binary in Nix.\nI have no idea how to build things in flakes, so consulting the wiki is pretty much a requirement 1! It covers things like how to enable flakes, and I won\u0026rsquo;t bother covering because I\u0026rsquo;ll only make a worse version of it.\nIt tells me about both the inputs and outputs schema. But because I only need nixpkgs for this one, there\u0026rsquo;s not much else for me to add to the inputs.\nHere\u0026rsquo;s the output schema:\n{ self, ... }@inputs: { # Executed by `nix flake check` checks.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Executed by `nix build .#\u0026lt;name\u0026gt;` packages.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Executed by `nix build .` defaultPackage.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = derivation; # Executed by `nix run .#\u0026lt;name\u0026gt;` apps.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = { type = \u0026#34;app\u0026#34;; program = \u0026#34;\u0026lt;store-path\u0026gt;\u0026#34;; }; # Executed by `nix run . -- \u0026lt;args?\u0026gt;` defaultApp.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = { type = \u0026#34;app\u0026#34;; program = \u0026#34;...\u0026#34;; }; # Used for nixpkgs packages, also accessible via `nix build .#\u0026lt;name\u0026gt;` legacyPackages.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Default overlay, consumed by other flakes overlay = final: prev: { }; # Same idea as overlay but a list or attrset of them. overlays = {}; # Default module, consumed by other flakes nixosModule = { config }: { options = {}; config = {}; }; # Same idea as nixosModule but a list or attrset of them. nixosModules = {}; # Used with `nixos-rebuild --flake .#\u0026lt;hostname\u0026gt;` # nixosConfigurations.\u0026#34;\u0026lt;hostname\u0026gt;\u0026#34;.config.system.build.toplevel must be a derivation nixosConfigurations.\u0026#34;\u0026lt;hostname\u0026gt;\u0026#34; = {}; # Used by `nix develop` devShell.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = derivation; # Used by `nix develop .#\u0026lt;name\u0026gt;` devShells.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Hydra build jobs hydraJobs.\u0026#34;\u0026lt;attr\u0026gt;\u0026#34;.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = derivation; # Used by `nix flake init -t \u0026lt;flake\u0026gt;` defaultTemplate = { path = \u0026#34;\u0026lt;store-path\u0026gt;\u0026#34;; description = \u0026#34;template description goes here?\u0026#34;; }; # Used by `nix flake init -t \u0026lt;flake\u0026gt;#\u0026lt;name\u0026gt;` templates.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = { path = \u0026#34;\u0026lt;store-path\u0026gt;\u0026#34;; description = \u0026#34;\u0026#34;; }; } That\u0026rsquo;s a lot.\noutputs is a lambda with a set as its argument. Since nix functions can only have one argument, putting the stuff you need in a set is how you get around that restriction. {self, ...} is some form of pattern matching the fields in a set, and @inputs binds the set to input. Cool. The latter isn\u0026rsquo;t that useful to me in this scenario though, so I\u0026rsquo;ll omit that. It seems that in every flake outputs, self must be there. I don\u0026rsquo;t understand what self is, but I\u0026rsquo;ll leave that for another time.\nWith the schema, there are two fields that seem important: packages, and defaultPackage. packages would be useful if I wanted to have multiple versions of postgrest available for me to use like postgres-8-0-0 and postgrest-9-0-0, but I don\u0026rsquo;t! I only need the latest version, which is 9.0.0 at the time of writing. So we can ignore that, and I\u0026rsquo;ll use defaultPackage instead.\nHere\u0026rsquo;s what we have so far:\n{ description = \u0026#34;REST API for any Postgres database\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; }; outputs = {self, nixpkgs}: { defaultPackage.x86_64-linux = with import nixpkgs { system = \u0026#34;x86_64-linux\u0026#34;; }; stdenv.mkDerivation rec { name = \u0026#34;postgrest-${version}\u0026#34;; version = \u0026#34;9.0.0\u0026#34;; # I still lack stuff here! }; }; } with import nixpkgs {system = \u0026quot;x86_64-linux\u0026quot;}; spares me from having to qualify everything like nixpkgs.system.\u0026quot;x86_64\u0026quot;.stdenv.mkDerivation which is handy 2. This brings stdenv into scope, and has mkDerivation which, from the name, makes a derivation; something I need for defaultPackage.\u0026lt;system\u0026gt;. Unfortunately, I couldn\u0026rsquo;t find any official documentation for mkDerivation that specifies every single field usable in it. Maybe it exists and that I just suck at Googling. That is definitely possible. There are some examples 3, especially in the wild.\nrec allows me to refer to the set\u0026rsquo;s own fields within it. I\u0026rsquo;m using the field version and interpolated it in name!\nAlright that\u0026rsquo;s it for the setup. Time to fetch the binary.\nFetching the binary The wiki has an example for fetching stuff from a URL, and using it in mkDerivation 4.\nsrc = fetchurl { url = \u0026#34;https://download.studio.link/releases/v${version}-stable/linux/studio-link-standalone-v${version}.tar.gz\u0026#34;; sha256 = \u0026#34;sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=\u0026#34;; }; So it looks like I need two things, a url which can be a tar file, and a sha256. The sha256 field is used to make something impure a little bit less unpredictable. If the release were somehow to change under the same name, then it would fail cause the SHA would have a different signature.\nBut\u0026hellip; how does one get the SHA? A trick is to just leave it blank. Nix will inform you and make a comparison of the expected vs actual signature.\nAdd this in the outputs schema:\nsrc = pkgs.fetchurl { # Remember `rec`! url = \u0026#34;https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\u0026#34;; sha256 = \u0026#34;\u0026#34;; }; and run nix build in the directory with this flake.nix file.\nsekun@nixos ~/P/g/n/postgrest (feature/postgrest)\u0026gt; nix build warning: Git tree '/home/sekun/Projects/gnawex' is dirty warning: found empty hash, assuming 'sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=' error: hash mismatch in fixed-output derivation '/nix/store/mag8ly8f0rlw5dqxj7ir8maa1bqgkyxv-postgrest-v9.0.0-linux-static-x64.tar.xz.drv': specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= got: sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4= error: 1 dependencies of derivation '/nix/store/yg6adsask3s2sg636m5dwy0c79dadg9g-postgrest-9.0.0.drv' failed to build sekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1]\u0026gt; It does fail, as expected. This is how it\u0026rsquo;ll be if ever the signature were to change. But there it is! It tells us what we specified, and what Nix got. So let\u0026rsquo;s yoink that and slap it in the schema.\nsrc = pkgs.fetchurl { url = \u0026#34;https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\u0026#34;; sha256 = \u0026#34;sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=\u0026#34;; }; Now that we have the binary, all that\u0026rsquo;s left is to install it.\nInstalling Going back to the example in 4:\nstdenv.mkDerivation rec { name = \u0026#34;studio-link-${version}\u0026#34;; version = \u0026#34;21.07.0\u0026#34;; src = fetchurl { url = \u0026#34;https://download.studio.link/releases/v${version}-stable/linux/studio-link-standalone-v${version}.tar.gz\u0026#34;; sha256 = \u0026#34;sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=\u0026#34;; }; nativeBuildInputs = [ autoPatchelfHook ]; buildInputs = [ alsaLib openssl zlib pulseaudio ]; sourceRoot = \u0026#34;.\u0026#34;; installPhase = \u0026#39;\u0026#39; install -m755 -D studio-link-standalone-v${version}$out/bin/studio-link \u0026#39;\u0026#39;; meta = with lib; { homepage = \u0026#34;https://studio-link.com\u0026#34;; description = \u0026#34;Voip transfer\u0026#34;; platforms = platforms.linux; }; } We can ignore nativeBuildInputs and buildInputs since those are used for declaring what dependencies should be there when building something. In this case, there\u0026rsquo;s nothing to build because we just got a pre-built binary. Nor do we have to provide any runtime dependencies because it\u0026rsquo;s a static binary. That leaves sourceRoot, installPhase, and meta left. I tried looking for more information about sourceRoot found some explanations but I was left unsure if I needed it. Let\u0026rsquo;s leave that out for now. We do need installPhase since we have to send it off to the Nix store. It looks like I can reuse this without much changes.\ninstallPhase = '' install -m755 -D postgrest $out/bin/postgrest ''; I have no idea what install is. And as usual, check the manual/wiki! The manual description tells me it\u0026rsquo;s how one copies files while setting attributes. -m755 sets the permissions to 755, postgrest is the source, and $out/bin/postgrest is the target. $out is set by Nix, which points to the Nix store with the package\u0026rsquo;s name for the folder. Alright, cool!\nTime to run nix build again to see if this works.\n\u0026hellip;and it doesn\u0026rsquo;t.\nsekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1]\u0026gt; nix build warning: Git tree '/home/sekun/Projects/gnawex' is dirty error: builder for '/nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv' failed with exit code 1; last 3 log lines: \u0026gt; unpacking sources \u0026gt; unpacking source archive /nix/store/644yqp1y3cgw45qfqsbxb013hm4r2zw6-postgrest-v9.0.0-linux-static-x64.tar.xz \u0026gt; unpacker appears to have produced no directories For full logs, run 'nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv'. The error seems to point out that it couldn\u0026rsquo;t unpack the tar anywhere. Running nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv seems to tell me the same thing.\nAlright alright, let\u0026rsquo;s take a look at what the manual has to say about sourceRoot:\n After running unpackPhase, the generic builder changes the current directory to the directory created by unpacking the sources. If there are multiple source directories, you should set sourceRoot to the name of the intended directory. Set sourceRoot = \u0026ldquo;.\u0026quot;; if you use srcs and control the unpack phase yourself.\n This isn\u0026rsquo;t really so helpful because I\u0026rsquo;m not using srcs, nor am I using unpackPhase, nor am I unpacking multiple sources! I am however specifying a remote file as src with fetchurl, which does seem to unpack it. I have no clue what fetchurl does because the manual doesn\u0026rsquo;t seem to cover it 5. No idea what else to do here so I\u0026rsquo;ll just follow the suggestion of adding sourceRoot \u0026quot;.\u0026quot;. Run nix build again, and see it finally work!\nHere\u0026rsquo;s the final flake:\n{ description = \u0026#34;REST API for any Postgres database\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; }; outputs = {self, nixpkgs}: { defaultPackage.x86_64-linux = with import nixpkgs { system = \u0026#34;x86_64-linux\u0026#34;; }; stdenv.mkDerivation rec { name = \u0026#34;postgrest-${version}\u0026#34;; version = \u0026#34;9.0.0\u0026#34;; # https://nixos.wiki/wiki/Packaging/Binaries src = pkgs.fetchurl { url = \u0026#34;https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\u0026#34;; sha256 = \u0026#34;sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=\u0026#34;; }; sourceRoot = \u0026#34;.\u0026#34;; installPhase = \u0026#39;\u0026#39; install -m755 -D postgrest $out/bin/postgrest \u0026#39;\u0026#39;; meta = with lib; { homepage = \u0026#34;https://postgrest.org\u0026#34;; description = \u0026#34;REST API for any Postgres database\u0026#34;; platforms = platforms.linux; }; }; }; } Importing a local flake to another flake Here\u0026rsquo;s the flake file that needs postgrest:\n{ description = \u0026#34;An independent MouseHunt marketplace\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; masterpkgs.url = \u0026#34;github:NixOS/nixpkgs/master\u0026#34;; flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; }; outputs = { self, nixpkgs, masterpkgs, flake-utils }: flake-utils.lib.eachSystem [ \u0026#34;x86_64-linux\u0026#34; ] (system: let pkgs = nixpkgs.legacyPackages.${system}; postgrest = postgrestPkg.defaultPackage.${system}; lib = nixpkgs.lib; in { devShell = pkgs.mkShell rec { buildInputs = [ masterpkgs.legacyPackages.${system}.pgadmin4 ]; }; }); }  Oh, you don\u0026rsquo;t know what GNAWEX 6 is? Well, it\u0026rsquo;s just an app I\u0026rsquo;ve been working on for a video game I\u0026rsquo;ve been playing for nearly 12 years. I\u0026rsquo;m not addicted, I swear. I\u0026rsquo;m only doing this to learn PostgreSQL\u0026rsquo;s cool features!\n Besides using flake-utils to make handling different \u0026lt;system\u0026gt;s more convenient, the flake does look pretty much the same. Now how does one refer to this local postgrest flake in this flake? Fortunately, the wiki 1 has an example in the inputs schema section:\n# local directories (for absolute paths you can omit \u0026#39;path:\u0026#39;) directory-example.url = \u0026#34;path:/path/to/repo\u0026#34;; We need to keep path: since we need a relative path since the postgrest flake is in ./nix/postgrest/flake.nix. Add this to the flake file that needs it, in its inputs set:\ninputs = { # ... postgrestPkg.url = \u0026#34;path:./nix/postgrest\u0026#34;; }; postgrestPkg can be anything, but I\u0026rsquo;m naming it postgrestPkg to avoid confusion with the actual postgrest package. Then, for convenience, I added this in the let expression:\npostgrest = postgrestPkg.defaultPackage.${system}; This binds postgres-9-0-0 to postgrest, which I use in devShell\u0026rsquo;s buildInputs. Here\u0026rsquo;s the final flake:\n{ description = \u0026#34;An independent MouseHunt marketplace\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; masterpkgs.url = \u0026#34;github:NixOS/nixpkgs/master\u0026#34;; postgrestPkg.url = \u0026#34;path:./nix/postgrest\u0026#34;; # New! flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; }; # V Add this one. Order matters. outputs = { self, nixpkgs, masterpkgs, postgrestPkg, flake-utils }: flake-utils.lib.eachSystem [ \u0026#34;x86_64-linux\u0026#34; ] (system: let pkgs = nixpkgs.legacyPackages.${system}; postgrest = postgrestPkg.defaultPackage.${system}; # For convenience lib = nixpkgs.lib; in { devShell = pkgs.mkShell rec { buildInputs = [ postgrest # A shiny `postgres` package! masterpkgs.legacyPackages.${system}.pgadmin4 ]; }; }); } Now postgrest is available in the shell environment:\ndirenv: loading ~/Projects/gnawex/.envrc direnv: using flake warning: Git tree '/home/sekun/Projects/gnawex' is dirty warning: Git tree '/home/sekun/Projects/gnawex' is dirty direnv: renewed cache direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DETERMINISTIC_BUILD +HOST_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_BUILD_CORES +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_INDENT_MAKE +NIX_LDFLAGS +NIX_STORE +NM +OBJCOPY +OBJDUMP +PYTHONHASHSEED +PYTHONNOUSERSITE +PYTHONPATH +RANLIB +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +_PYTHON_HOST_PLATFORM +_PYTHON_SYSCONFIGDATA_NAME +buildInputs +buildPhase +builder +configureFlags +depsBuildBuild +depsBuildBuildPropagated +depsBuildTarget +depsBuildTargetPropagated +depsHostHost +depsHostHostPropagated +depsTargetTarget +depsTargetTargetPropagated +doCheck +doInstallCheck +dontAddDisableDepTrack +name +nativeBuildInputs +out +outputs +patches +phases +propagatedBuildInputs +propagatedNativeBuildInputs +shell +shellHook +stdenv +strictDeps +system ~PATH ~XDG_DATA_DIRS sekun@nixos ~/P/gnawex (feature/postgrest)\u0026gt; postgrest Usage: postgrest [-e|--example] [--dump-config | --dump-schema] FILENAME PostgREST 9.0.0 / create a REST API to an existing Postgres database Available options: -h,--help Show this help text -e,--example Show an example configuration file --dump-config Dump loaded configuration and exit --dump-schema Dump loaded schema as JSON and exit (for debugging, output structure is unstable) FILENAME Path to configuration file (optional with PGRST_ environment variables) To run PostgREST, please pass the FILENAME argument or set PGRST_ environment variables. If you\u0026rsquo;re wondering how to load the nix shell automatically without running nix develop, look into direnv, and nix-direnv! I\u0026rsquo;ll probably write about that too since it\u0026rsquo;s so damn handy that I can\u0026rsquo;t live without it. It\u0026rsquo;s like virtualenv on crack.\nConclusion Could\u0026rsquo;ve been easier if everything was in the manual. But it isn\u0026rsquo;t so the entire process of figuring it out involved a lot of Google-fu + man + GitHub code search.\nThat\u0026rsquo;s it from me for now. It\u0026rsquo;s a relatively basic thing to do in Nix since this is in many leagues easier than building a project with it. Still useful though since there\u0026rsquo;s a lot of pre-built, static binaries out there.\n  https://nixos.wiki/wiki/Flakes\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://nixos.org/guides/nix-pills/basics-of-language.html#idm140737320525664\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#flake-format\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://nixos.wiki/wiki/Packaging/Binaries\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/NixOS/nix/issues/1489\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/gnawex/gnawex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://blog.sekun.dev/posts/packaging-prebuilt-binaries-with-nix/","summary":"Here\u0026rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn\u0026rsquo;t have the version you want. Fortunately, there\u0026rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?","title":"Packaging Pre-built Binaries with Nix Flake"}]