[{"content":"Recently, I experimented with running NixOS on a DigitalOcean droplet (which I will probably write about in the future), and migrated some of my toy projects from App Platform. During the migration process, I realized that I would have to somehow handle the DB certificate, and other sensitive credentials. I can\u0026rsquo;t just hardcode these!\nOne of the more popular projects for problems like this is agenix. Their README for how to use it was a bit confusing (for me) so hopefully this post will be of use to others.\nThere are two parts to this post: 1) creating secrets with agenix, and 2) reading said secrets in a remote NixOS server. Of course you could use it for different things, and my example isn\u0026rsquo;t exactly the simplest.\n Note: I\u0026rsquo;m not saying this is the best way to do things. Please let me know if there are any glaring issues you find!\n Prerequisites Here\u0026rsquo;s a checklist for what\u0026rsquo;s needed:\n agenix CLI present in your computer agenix\u0026rsquo;s module to the system you want secrets to be read in An SSH key pair present in the machine you\u0026rsquo;ll create the secrets in as well as in the machine you want the secrets to be read in  Installing agenix is documented well in their README so feel free to consult it.\nAbout agenix Age files Secrets are encrypted and stored by agenix in these things called age files. These files have the .age format. For agenix to know who is allowed to read these age files for their secrets, it looks for a secrets.nix file in the current directory for the rules.\nSo, what are rules?\nRules Let\u0026rsquo;s see what the agenix CLI says:\n$ agenix agenix - edit and rekey age secret files agenix -e FILE [-i PRIVATE_KEY] agenix -r [-i PRIVATE_KEY] options: -h, --help show help -e, --edit FILE edits FILE using $EDITOR -r, --rekey re-encrypts all secrets with specified recipients -i, --identity identity to use when decrypting -v, --verbose verbose output FILE an age-encrypted file PRIVATE_KEY a path to a private SSH key used to decrypt file EDITOR environment variable of editor to use when editing FILE RULES environment variable with path to Nix file specifying recipient public keys. Defaults to './secrets.nix' agenix version: 0.13.0 age binary path: /nix/store/kfasn0129ac0xn8wfvf7mq38rxhbc725-rage-0.8.1/bin/rage age version: rage 0.8.1 Specifically:\n RULES environment variable with path to Nix file specifying recipient public keys. Defaults to \u0026lsquo;./secrets.nix\u0026rsquo;\n In the aforementioned file, we\u0026rsquo;re able to say whose key can decrypt what age file. Let\u0026rsquo;s create this file first.\n# We'll store the rules, and age files in the `secrets` folder mkdir secrets touch secrets.nix For the example later, I\u0026rsquo;ll need two files: one containing the DB CA certificate, and the DB password. So I\u0026rsquo;ll create a rule for each age file I\u0026rsquo;m going to generate later on.\nHere\u0026rsquo;s how it looks like:\n# secrets/secrets.nix let peepeepoopoo = \u0026#34;ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIB/Oxx/jZS7TRqjp2kwaYavzcxxKFTrStikFrtZq3q3l root@peepeepoopoo\u0026#34;; in { \u0026#34;emojiedDBPassword.age\u0026#34;.publicKeys = [ peepeepoopoo ]; \u0026#34;emojiedDBCACert.age\u0026#34;.publicKeys = [ peepeepoopoo ]; } So for reading/creating emojiedDBPassword.age for example, agenix looks for the private key pair of the public key that was supplied. Otherwise, it prohibits the user from doing so.\nCreating a secret We\u0026rsquo;ll need the agenix CLI to create an age file containing our encrypted secret, and run this:\n$ agenix -e emojiedDBCACert.age This opens a text editor for you to put the secret in.\n  Updating a secret\u0026rsquo;s public keys If you need to add public keys for existing age files, update the secrets.nix file accordingly, and run agenix -r. Make sure you\u0026rsquo;re in the same directory as the secrets.nix, and age files.\nIt would show you something like this if it succeeds:\nsekun@ichi /s/S/d/secrets (main)\u0026gt; agenix -r rekeying emojiedDBCACert.age... rekeying emojiedDBPassword.age... Now our age files are ready to be used!\nReading secrets in Nix I mentioned earlier that my use case is for supplying the DB CA certificate, and DB password to the emojied app for it to connect with the DB properly. I won\u0026rsquo;t get into the details of how I set up the server. Rather, I\u0026rsquo;ll just include the parts necessary. If you wish to read the full config files, check the repo although peepeepoopoo here is a throwaway server. Hence not in the repo.\nWhat I need in the remote server called peepeepoopoo (where emojied is running) are the ff:\n agenix NixOS module Age files SSH key permitted to decrypt said age files  flake.nix:\n{ description = \u0026#34;Example\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs/nixos-22.05\u0026#34;; emojiedpkg.url = \u0026#34;github:sekunho/emojied\u0026#34;; agenix.url = \u0026#34;github:ryantm/agenix\u0026#34;; }; outputs = { self, nixpkgs, emojiedpkg, agenix }: let system = \u0026#34;x86_64-linux\u0026#34;; pkgs = nixpkgs.legacyPackages.${system}; emojied = emojiedpkg.packages.${system}.emojied; in { nixosConfigurations.peepeepoopoo = nixpkgs.lib.nixosSystem { inherit system; modules = [ emojiedpkg.nixosModule ./hosts/peepeepoopoo/configuration.nix agenix.nixosModules.age ]; # Applies the configuration.nix function to these arguments specialArgs = { inherit pkgs; inherit emojied; }; }; }; } All that\u0026rsquo;s left to do is specify where the age files are located, and referencing the decrypted age files' paths.\nhosts/peepeepoopoo/configuration.nix:\n{ modulesPath, lib, config, pkgs, ... }: { imports = lib.optional (builtins.pathExists ./do-userdata.nix) ./do-userdata.nix ++ [ (modulesPath + \u0026#34;/virtualisation/digital-ocean-config.nix\u0026#34;) ]; programs.ssh = { startAgent = true; extraConfig = \u0026#39;\u0026#39; AddKeysToAgent yes \u0026#39;\u0026#39;; }; nix = { package = pkgs.nixVersions.nix_2_9; extraOptions = \u0026#39;\u0026#39; experimental-features = nix-command flakes \u0026#39;\u0026#39;; settings.trusted-public-keys = [ \u0026#34;hydra.iohk.io:f/Ea+s+dFdN+3Y/G+FDgSq+a5NEWhJGzdjvKNGv0/EQ=\u0026#34; \u0026#34;iohk.cachix.org-1:DpRUyj7h7V830dp/i6Nti+NEO2/nhblbov/8MW7Rqoo=\u0026#34; \u0026#34;nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=\u0026#34; ]; settings.substituters = [ \u0026#34;https://cache.iog.io\u0026#34; \u0026#34;https://iohk.cachix.org\u0026#34; \u0026#34;https://nix-community.cachix.org\u0026#34; ]; }; age = { # We\u0026#39;re letting `agenix` know where the locations of the age files will be # in the server. secrets = { emojiedDBPassword.file = \u0026#34;/root/secrets/emojiedDBPassword.age\u0026#34;; emojiedDBCACert.file = \u0026#34;/root/secrets/emojiedDBCACert.age\u0026#34;; }; # Private key of the SSH key pair. This is the other pair of what was supplied # in `secrets.nix`. # # This tells `agenix` where to look for the private key. identityPaths = [ \u0026#34;/root/.ssh/id_ed25519\u0026#34; ]; }; # List services that you want to enable: services = { emojied = { enable = true; port = \u0026#34;3000\u0026#34;; dbHost = \u0026#34;\u0026lt;REPLACE_WITH_YOUR_OWN\u0026gt;\u0026#34;; dbName = \u0026#34;\u0026lt;REPLACE_WITH_YOUR_OWN\u0026gt;\u0026#34;; dbPort = \u0026#34;\u0026lt;REPLACE_WITH_YOUR_OWN\u0026gt;\u0026#34;; dbUser = \u0026#34;\u0026lt;REPLACE_WITH_YOUR_OWN\u0026gt;\u0026#34;; dbPoolSize = \u0026#34;5\u0026#34;; dbPasswordFile = config.age.secrets.emojiedDBPassword.path; dbCACertFile = config.age.secrets.emojiedDBCACert.path; }; openssh = { enable = true; permitRootLogin = \u0026#34;prohibit-password\u0026#34;; passwordAuthentication = false; }; }; networking = { firewall = { enable = true; allowedTCPPorts = [ 22 3000 ]; }; }; # List packages installed in system profile. To search, run: # $ nix search wget environment = { systemPackages = with pkgs; []; loginShellInit = \u0026#39;\u0026#39; export SSH_AUTH_SOCK=\u0026#34;$XDG_RUNTIME_DIR/ssh-agent.socket\u0026#34; \u0026#39;\u0026#39;; }; system.stateVersion = \u0026#34;22.05\u0026#34;; } Now we can move the secrets folder, and the SSH key (if it\u0026rsquo;s not already there) from our host machine to the remote server.\n$ scp secrets root@\u0026lt;SERVER_IP\u0026gt;:/root/ $ scp ~/.ssh/\u0026lt;YOUR_KEY\u0026gt; root@\u0026lt;SERVER_IP\u0026gt;:/root/.ssh/id_ed25519 $ scp ~/.ssh/\u0026lt;YOUR_KEY\u0026gt;.pub root@\u0026lt;SERVER_IP\u0026gt;:/root/.ssh/id_ed25519.pub Then hit build and apply the config:\n$ nixos-rebuild switch \\ --flake .#peepeepoopoo \\ --target-host root@\u0026lt;SERVER_IP\u0026gt; \\ --build-host localhost copying 3 paths... copying path '/nix/store/lali119kww58c4df3b1w61yzg5an1mr7-system-units' to 'ssh://root@\u0026lt;SERVER_IP\u0026gt;'... copying path '/nix/store/g1izspgbn34hmlll2hby5qapx90nm43p-etc' to 'ssh://root@\u0026lt;SERVER_IP\u0026gt;'... copying path '/nix/store/739zphavd4d1vjfnd8v2b1bpm0dzwxz6-nixos-system-unnamed-22.05.20221024.6107f97' to 'ssh://root@\u0026lt;SERVER_IP\u0026gt;'... updating GRUB 2 menu... stopping the following units: emojied.service activating the configuration... [agenix] creating new generation in /run/agenix.d/1 [agenix] decrypting secrets... decrypting '/root/secrets/emojiedDBCACert.age' to '/run/agenix.d/1/emojiedDBCACert'... decrypting '/root/secrets/emojiedDBPassword.age' to '/run/agenix.d/1/emojiedDBPassword'... [agenix] symlinking new secrets to /run/agenix (generation 1)... [agenix] chowning... setting up /etc... reloading user units for root... setting up tmpfiles starting the following units: emojied.service the following new units were started: run-agenix.d.mount Which gives me this beautiful creation:\n  The abomination now works!\n  ","permalink":"https://blog.sekun.dev/posts/manage-secrets-in-nixos/","summary":"Recently, I experimented with running NixOS on a DigitalOcean droplet (which I will probably write about in the future), and migrated some of my toy projects from App Platform. During the migration process, I realized that I would have to somehow handle the DB certificate, and other sensitive credentials. I can\u0026rsquo;t just hardcode these!\nOne of the more popular projects for problems like this is agenix. Their README for how to use it was a bit confusing (for me) so hopefully this post will be of use to others.","title":"Manage Secrets in NixOS"},{"content":"Introduction A few days ago, I released the abomination of a project called emojied (website, repo) to the world. It went great, I\u0026rsquo;m glad people found it funny. However, I\u0026rsquo;m not too pleased with the deployment process: from building the project to shipping it. I made heavy use of Docker to build the necessary static assets, and binary.\nHere\u0026rsquo;s the current setup:\n Dev environment  PostgreSQL (handled by NixOS) rustc, openssl, cargo, etc. (handled by Nix)   CI/CD (GitHub Actions)  Build static assets (just in GitHub Actions) Build static binary (Docker, ekidd/rust-musl-builder) Build prod image (Docker, alpine)    I\u0026rsquo;ve already tried to remove as much responsibility from #3 by building the static assets, and binary beforehand; I really need to do is copy it over. #2 is where the pain is because it does not reuse the dependencies from #1. So, I have two options here:\n Use Docker for everything, but this complicates my dev environment cause now I have to deal with containers; or I use Nix for everything, including constructing the prod image.  I dislike the idea of using containers if all you want is reproducibility because it seems like an overkill. It\u0026rsquo;s annoying to setup volumes, annoying to manage permissions, annoying to wait for it to pull an entire image. On the other hand, while Nix is pretty difficult, it seems like a saner approach for what I want to do, so I chose it.\nSo, here\u0026rsquo;s how it went. (Spoiler: Kinda painful to setup)\nStarting point This is the starting flake file:\n{ description = \u0026#34;\u0026#34;; inputs = { # 1 nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; # Like `nixpkgs` but more bleeding-edge nixos-unstable.url = \u0026#34;github:NixOS/nixpkgs/nixos-unstable\u0026#34;; # 2 flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; # 3 naersk.url = \u0026#34;github:nix-community/naersk\u0026#34;; }; outputs = { self, nixpkgs, nixos-unstable, flake-utils, naersk }: flake-utils.lib.eachSystem [ \u0026#34;x86_64-linux\u0026#34; ] (system: let pkgs = nixpkgs.legacyPackages.${system}; naersk-lib = naersk.lib.\u0026#34;${system}\u0026#34;.override { cargo = pkgs.cargo; rustc = pkgs.rustc; }; in rec { # Build binary packages.emojied = naersk-lib.buildPackage { pname = \u0026#34;emojied\u0026#34;; root = ./.; }; # The package that gets built when I run `nix build` defaultPackage = packages.emojied; apps.emojied = flake-utils.lib.mkApp { drv = packages.emojied; }; }); }  nixpkgs is like a package repository. This is where you get rustc, cargo, etc. for example. flake-utils just makes dealing with flakes a bit more convenient, especially with multiple OSes (only doing Linux for now). naersk makes it easier to build static Rust binaries.  These are all inputs, where everything in the outputs field is sourced from. outputs is where everything gets packaged. Another thing is, to help with reproducibility, it pins these inputs to a specific GitHub commit via a lock file. So no version numbers, but down to the commit. This is how projects can be built in the future in the exact same way as now.\nIf you peek into flake.lock, you\u0026rsquo;ll find something like this:\n\u0026quot;naersk\u0026quot;: { \u0026quot;inputs\u0026quot;: { \u0026quot;nixpkgs\u0026quot;: \u0026quot;nixpkgs\u0026quot; }, \u0026quot;locked\u0026quot;: { \u0026quot;lastModified\u0026quot;: 1649096192, \u0026quot;narHash\u0026quot;: \u0026quot;sha256-7O8e+eZEYeU+ET98u/zW5epuoN/xYx9G+CIh4DjZVzY=\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;nix-community\u0026quot;, \u0026quot;repo\u0026quot;: \u0026quot;naersk\u0026quot;, \u0026quot;rev\u0026quot;: \u0026quot;d626f73332a8f587b613b0afe7293dd0777be07d\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;github\u0026quot; }, \u0026quot;original\u0026quot;: { \u0026quot;owner\u0026quot;: \u0026quot;nix-community\u0026quot;, \u0026quot;repo\u0026quot;: \u0026quot;naersk\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;github\u0026quot; } }, \u0026quot;nixpkgs\u0026quot;: { \u0026quot;locked\u0026quot;: { \u0026quot;lastModified\u0026quot;: 1648219316, \u0026quot;narHash\u0026quot;: \u0026quot;sha256-Ctij+dOi0ZZIfX5eMhgwugfvB+WZSrvVNAyAuANOsnQ=\u0026quot;, \u0026quot;owner\u0026quot;: \u0026quot;NixOS\u0026quot;, \u0026quot;repo\u0026quot;: \u0026quot;nixpkgs\u0026quot;, \u0026quot;rev\u0026quot;: \u0026quot;30d3d79b7d3607d56546dd2a6b49e156ba0ec634\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;github\u0026quot; }, \u0026quot;original\u0026quot;: { \u0026quot;id\u0026quot;: \u0026quot;nixpkgs\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;indirect\u0026quot; } } There are more stuff in it, but hopefully this will make things a bit clearer.\nThat\u0026rsquo;s the best ELI5 I can think of, so I recommend you check out the documentation for a more technical explanation.\nSo, I run nix build and\u0026hellip;\nProblem 0: OpenSSL Bam.\nerror: builder for '/nix/store/pv9szkam1rawk40ywp3v89k53zg4b1l4-emojied-deps-0.1.0.drv' failed with exit code 101; last 10 log lines: \u0026gt; It looks like you're compiling on Linux and also targeting Linux. Currently this \u0026gt; requires the `pkg-config` utility to find OpenSSL but unfortunately `pkg-config` \u0026gt; could not be found. If you have OpenSSL installed you can likely fix this by \u0026gt; installing `pkg-config`. \u0026gt; \u0026gt; ', /sources/openssl-sys-0.9.72/build/find_normal.rs:180:5 \u0026gt; note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace \u0026gt; warning: build failed, waiting for other jobs to finish... \u0026gt; error: build failed \u0026gt; [naersk] cargo returned with exit code 101, exiting For full logs, run 'nix log /nix/store/pv9szkam1rawk40ywp3v89k53zg4b1l4-emojied-deps-0.1.0.drv'. error: 1 dependencies of derivation '/nix/store/r0h49v7i2vg5dckb9h2g8p7na048rk4g-emojied-0.1.0.drv' failed to build I\u0026rsquo;ve seen this error before! Since emojied uses native-tls, and since it\u0026rsquo;s just a wrapper around OpenSSL, I need to have OpenSSL around. Thankfully, naersk has a buildInputs attribute for us to use.\npackages.emojied = naersk-lib.buildPackage { pname = \u0026#34;emojied\u0026#34;; root = ./.; buildInputs = with pkgs; [ openssl pkg-config ]; }; Ran nix build, and I\u0026rsquo;m greeted with another problem!\nProblem 1: git submodule woes Compiling maud_macros v0.23.0 (https://github.com/lambda-fairy/maud?branch=main#e6787cd6) error: could not compile `maud_macros` due to 3 previous errors warning: build failed, waiting for other jobs to finish... error: build failed error[E0583]: file not found for module `escape` --\u0026gt; /sources/maud_macros-0.23.0-e6787cd62165a075c7f16a32f8bbacc398f52d13/src/lib.rs:9:1 | 9 | mod escape; | ^^^^^^^^^^^ | = help: to create the module `escape`, create file \u0026quot;/nix/store/shixfmbv64zzi9i0rzb9c8870ydm7cf2-crates-io/maud_macr\u0026gt; error[E0425]: cannot find function `escape_to_string` in module `escape` --\u0026gt; /sources/maud_macros-0.23.0-e6787cd62165a075c7f16a32f8bbacc398f52d13/src/generate.rs:272:17 | 272 | escape::escape_to_string(string, \u0026amp;mut self.tail); | ^^^^^^^^^^^^^^^^ not found in `escape` error: aborting due to 2 previous errors Some errors have detailed explanations: E0425, E0583. For more information about an error, try `rustc --explain E0425`. [naersk] cargo returned with exit code 101, exiting It\u0026rsquo;s telling me that cargo can\u0026rsquo;t resolve the escape module for maud_macros. I took a look at the source, and initially seemed like it\u0026rsquo;s a submodule:\nTurns out there\u0026rsquo;s a ticket (#110) pointing out that submodules isn\u0026rsquo;t supported by naersk. Fortunately, by the time I read this, there was a PR ready that fixed this. All it required was adding gitSubmodules = true;:\npackages.emojied = naersk-lib.buildPackage { pname = \u0026#34;emojied\u0026#34;; root = ./.; gitSubmodules = true; }; So this fixes everything then, right?\nWrong.\nProblem 2: Symlink woes Remember how I said it was a submodule? Well, it turns out that escape.rs is actually a symlink (the icons look too similar!). cargo handles it just fine so running cargo build will work out. But this isn\u0026rsquo;t the case for naersk. I couldn\u0026rsquo;t find any issue talking about symlinks so I opened one (#230). Unfortunately, I had no idea how to fix it, so I just decided to manually clone it, and remove the symlink for a copy instead. It\u0026rsquo;s only one file, so it isn\u0026rsquo;t that big of a deal.\nKind of a hack, but it works now! A binary is available in ./result/bin/, albeit a symlink. I ran it with:\nPG__DBNAME=\u0026#34;emojied_db\u0026#34; PG__HOST=\u0026#34;localhost\u0026#34; PG__USER=\u0026#34;sekun\u0026#34; PG__PORT=\u0026#34;5432\u0026#34; \\  ./result/bin/emojied \u0026hellip;and I was greeted with this unstyled page:\nProblem 3: Static assets emojied is comprised of two things: a server binary, and static assets. These static assets are built using tailwindcss\u0026rsquo;s CLI, and esbuild\u0026hellip; which was not handled by naersk. It does not seem to provide an escape hatch, which makes sense anyway cause it would be kinda weird to do things unrelated to Rust in a Rust builder.\nNow what?\nWell, I found out about overrideAttrs and it is wonderful.\n{ # ... outputs = { self, nixpkgs, nixos-unstable, flake-utils, naersk }: flake-utils.lib.eachSystem [ \u0026#34;x86_64-linux\u0026#34; ] (system: let pkgs = nixpkgs.legacyPackages.${system}; unstablepkgs = nixos-unstable.legacyPackages.${system}; naersk-lib = naersk.lib.\u0026#34;${system}\u0026#34;.override { cargo = pkgs.cargo; rustc = pkgs.rustc; }; # I moved it up here so I could bind it to `emojied`. emojied = (naersk-lib.buildPackage { pname = \u0026#34;emojied\u0026#34;; root = ./.; nativeBuildInputs = with pkgs; [ ]; buildInputs = with pkgs; [ openssl pkg-config ]; }).overrideAttrs (old: { # I get access to `old` which has the previous attributes. # And I get to override anything! nativeBuildInputs = old.nativeBuildInputs ++ [ unstablepkgs.nodePackages.typescript unstablepkgs.nodePackages.tailwindcss unstablepkgs.esbuild ]; buildInputs = old.buildInputs; buildPhase = old.buildPhase + \u0026#39;\u0026#39; tailwindcss \\ --input assets/app.css \\ --config assets/tailwind.config.js \\ --output public/app.css \\ --minify esbuild \\ assets/app.ts \\ --outdir=public/ \\ --minify \u0026#39;\u0026#39;; installPhase = old.installPhase + \u0026#39;\u0026#39; mv public $out/bin mv bin/run $out/bin/run \u0026#39;\u0026#39;; }); in rec { packages.emojied = emojied; defaultPackage = packages.emojied; apps.emojied = flake-utils.lib.mkApp { drv = packages.emojied; }; }); } I removed gitSubmodules = true since it wasn\u0026rsquo;t necessary anymore. buildPackage just spits out an attribute set, I can override it to add more things. Here, I added new native build inputs (build time), new steps to buildPhase, and installPhase for the static assets.\nAnd I ran it like this:\ncd result/bin PG__DBNAME=\u0026#34;emojied_db\u0026#34; PG__HOST=\u0026#34;localhost\u0026#34; PG__USER=\u0026#34;sekun\u0026#34; PG__PORT=\u0026#34;5432\u0026#34; \\  ./emojied Beautiful.\nOkay, so that seems to work but I have to run emojied in the same directory as public/ cause otherwise it won\u0026rsquo;t find anything. Which is expected because:\npub async fn stylesheet() -\u0026gt; (StatusCode, HeaderMap, String) { let mut headers = HeaderMap::new(); match fs::read_to_string(\u0026#34;public/app.css\u0026#34;) { // ^ Relative path. Good job me!  Ok(content) =\u0026gt; { headers.insert( HeaderName::from_static(\u0026#34;content-type\u0026#34;), HeaderValue::from_static(\u0026#34;text/css; charset=utf-8\u0026#34;), ); (StatusCode::OK, headers, content) } Err(_e) =\u0026gt; (StatusCode::NOT_FOUND, headers, String::from(\u0026#34;Not found\u0026#34;)), } } I\u0026rsquo;m using relative paths! But other than that, it works. It\u0026rsquo;s not exactly an issue for the way I\u0026rsquo;m using it, which is:\n Build the binary Build static assets Copy files from #1 and #2, and throw it into an image.  But with nix run, it gives me broken styles again. I don\u0026rsquo;t want it to depend on where I run it! So. Close.\nProblem 4: Making it work™ So the problem is that the file paths are relative which makes it depend on where I run the binary. The plan then is to provide the static asset directory path during runtime!\nThis way it\u0026rsquo;s flexible enough to:\n Ship off to a Docker image; and Use nix run without breaking anything.  Something like this would be nice:\nPG__DBNAME=\u0026quot;emojied_db\u0026quot; \\ PG__HOST=\u0026quot;localhost\u0026quot; \\ PG__USER=\u0026quot;sekun\u0026quot; \\ PG__PORT=\u0026quot;5432\u0026quot; \\ APP__STATIC_ASSETS=\u0026quot;/foo/bar/public/\u0026quot; \\ ./emojied I added another field to AppConfig, and checked if there\u0026rsquo;s an argument called static_assets_path:\n// src/config.rs  struct AppConfig { // ...  pub static_assets_path: String // See disclaimer below } Loaded it from the environment:\n// src/config.rs  let static_assets_path = env::var(\u0026#34;APP__STATIC_ASSETS\u0026#34;) .map_err(|_| Error::MissingStaticAssetsPath)?; // ...  Ok(AppConfig { // ...  static_assets_path, // New! }) Add AppConfig to the middleware:\n// ... let config = Arc::new(config); let app = Router::new() // ...  .layer(Extension(config)); And in the functions serving the files:\npub async fn js( Extension(config): Extension\u0026lt;Arc\u0026lt;AppConfig\u0026gt;\u0026gt; // New ) -\u0026gt; (StatusCode, HeaderMap, String) { let mut headers = HeaderMap::new(); let mut static_assets_path = config.static_assets_path.clone(); // New  static_assets_path.push_str(\u0026#34;public/app.js\u0026#34;); // New  // Shiny, new path  match fs::read_to_string(static_assets_path) { Ok(content) =\u0026gt; { headers.insert( HeaderName::from_static(\u0026#34;content-type\u0026#34;), HeaderValue::from_static(\u0026#34;application/javascript; charset=utf-8\u0026#34;), ); (StatusCode::OK, headers, content) } Err(_e) =\u0026gt; (StatusCode::NOT_FOUND, headers, String::from(\u0026#34;Not found\u0026#34;)), } } \u0026hellip;which I then repeated in 2 more functions because I was too lazy to make one endpoint for static assets. Now, I feel the pain of my laziness.\n Disclaimer: Before you come after me with pitchforks, I later did a tiny refactor which uses PathBuf rather than a String.\n Okay, but then I still need a way to set the environment variable automatically, right? Currently, it\u0026rsquo;s not very convenient to do it every time it\u0026rsquo;s called with nix run. Turns out makeWrapper exists. (Thanks K900!)\n{ # ... packages.emojied-unwrapped = emojied; # New packages.emojied = pkgs.symlinkJoin { name = \u0026#34;emojied\u0026#34;; paths = [ emojied ]; buildInputs = [ pkgs.makeWrapper ]; postBuild = \u0026#39;\u0026#39; wrapProgram $out/bin/emojied \\ --set APP__STATIC_ASSETS \u0026#34;${emojied}/bin/public\u0026#34; # ^ What a convenient way to get the path \u0026#39;\u0026#39;; }; # ... } So I\u0026rsquo;ll get the \u0026ldquo;wrapped\u0026rdquo; version of emojied with nix build, which has the static assets path already applied. Doing so gets me this:\nsekun@nixos ~/P/emojiurl (chore/nixify-package)\u0026gt; nix build sekun@nixos ~/P/emojiurl (chore/nixify-package)\u0026gt; ls -la result/bin total 20 dr-xr-xr-x 3 root root 4096 Jan 1 1970 . dr-xr-xr-x 3 root root 4096 Jan 1 1970 .. -r-xr-xr-x 1 root root 264 Jan 1 1970 emojied lrwxrwxrwx 1 root root 69 Jan 1 1970 .emojied-wrapped -\u0026gt; /nix/store/7nh13gwhhlmfmmb6qss47axj7nd99jw7-emojied-0.1.0/bin/emojied dr-xr-xr-x 2 root root 4096 Jan 1 1970 public sekun@nixos ~/P/emojiurl (chore/nixify-package)\u0026gt; ls -la # ... lrwxrwxrwx 1 sekun users 51 Apr 12 22:55 result -\u0026gt; /nix/store/300n6rjxm88asmqhv99hid9mi8148xjs-emojied #... So, it symlinked .emojied-wrapped to the original emojied, and result is symlinked to a wrapped version of it. Is this another derivation? Seems like it, although I don\u0026rsquo;t really know since I\u0026rsquo;m not so familiar with this. I\u0026rsquo;ll have to do more reading. I\u0026rsquo;m just gonna manually test it to verify if it all works. .#emojied-unwrapped needs to complain about the missing assets path if I don\u0026rsquo;t provide one, and .#emojied shouldn\u0026rsquo;t.\nsekun@nixos ~/P/emojiurl (chore/nixify-package)\u0026gt; PG__DBNAME=\u0026#34;emojied_db\u0026#34; PG__HOST=\u0026#34;localhost\u0026#34; PG__USER=\u0026#34;sekun\u0026#34; PG__PORT=\u0026#34;5432\u0026#34; nix run .#emojied-unwrapped Loading configuration from environment Application config error: Missing environment variable: `APP__STATIC_ASSETS=\u0026lt;PATH_TO_FILES\u0026gt;` sekun@nixos ~/P/emojiurl (chore/nixify-package) [1]\u0026gt; PG__DBNAME=\u0026#34;emojied_db\u0026#34; PG__HOST=\u0026#34;localhost\u0026#34; PG__USER=\u0026#34;sekun\u0026#34; PG__PORT=\u0026#34;5432\u0026#34; nix run Loading configuration from environment Attempting to establish a database connection Database connection established \u0026hellip;and it works as expected. The second one also serves the static assets just fine! Hooray.\nProblem 5: Copy all that to a Docker image The final step is copying what was built by Nix to a Docker image. I\u0026rsquo;m currently using a Dockerfile for that but this won\u0026rsquo;t work with this new setup. The problem now is that Docker doesn\u0026rsquo;t resolve symlinks that point outside the context, which is problematic since result is a symlink that points to some place in /nix/store! I could do some dirty hacks, but I could also just use Nix to build a Docker image for me.\nWait, did you say Nix could build Docker images?\nOh yeah, big time; nix.dev has a great starting point [^9] for doing so.\nHere\u0026rsquo;s what I ended up with:\n# flake.nix # ... # In `outputs` packages.emojied-docker = pkgs.dockerTools.buildImage { name = \u0026#34;emojied-docker\u0026#34;; tag = \u0026#34;latest\u0026#34;; contents = [ pkgs.bash ]; config = { WorkingDir = \u0026#34;/app\u0026#34;; Env = [ \u0026#34;PATH=${pkgs.coreutils}/bin/:${packages.emojied}/bin\u0026#34; ]; ExposedPorts = { \u0026#34;3000/tcp\u0026#34; = {}; }; # bin/run is a script that handles the dumping of CA certs, and runs the # emojied server. Cmd = [ \u0026#34;${packages.emojied}/bin/run\u0026#34; ]; }; }; If you squint hard enough, the contents of config just looks like a Nix version of a Dockerfile, which it is! The other cool part is now the package versions are in sync no matter what environment it is in. contents allows me to throw in Nix packages to the image. Since it seemed like the PATHs aren\u0026rsquo;t set automatically, I had to specify it in Env for coreutils, and emojied.\nIt\u0026rsquo;s basically like the other packages created, like emojied, and emojied-unwrapped. Which means I can build it in the exact same way as them:\n# Don\u0026#39;t mind the branch change. I ran this in the morning. sekun@nixos ~/P/emojiurl (main)\u0026gt; nix build .#emojied-docker # some build-related output sekun@nixos ~/P/emojiurl (main)\u0026gt; ls -la # ... lrwxrwxrwx 1 sekun users 78 Apr 13 12:28 result -\u0026gt; /nix/store/vmrja5imhrfhvl082j5qkqahcfj85adk-docker-image-emojied-docker.tar.gz # ... Instead, result is a symlink to some image tar file which you can load with docker load \u0026lt; result.\nsekun@nixos ~/P/emojiurl (main)\u0026gt; docker load \u0026lt; result Loaded image: emojied-docker:latest sekun@nixos ~/P/emojiurl (main)\u0026gt; docker images # ... emojied-docker latest 1a9092013b19 52 years ago 50MB Sweet!\nAll that\u0026rsquo;s left is to update the CI for these new steps, which is on the simpler side of things now:\nname: CI/CD on: push: branches: - main jobs: deploy: name: Build release and deploy runs-on: ubuntu-20.04 steps: - name: Checkout repo uses: actions/checkout@v2 - name: Setup Nix uses: cachix/install-nix-action@v15 - name: Login to Docker Hub uses: docker/login-action@v1 with: username: ${{ secrets.DOCKER_HUB_USERNAME }} password: ${{ secrets.DOCKER_HUB_PASSWORD }} - name: Build image run: |nix build .#emojied-docker docker load \u0026lt; result - name: Rename image run: docker tag emojied-docker:latest hsekun/emojied:latest - name: Push image run: docker push hsekun/emojied:latest It\u0026rsquo;s just so much easier, and I have more confidence that the CI will work as intended now that Nix is handling the important parts, which I can do locally. Not to say that Docker can\u0026rsquo;t do the same thing, but I found that there were some differences with volumes that made it painful to debug.\nConclusion While it did simplify things such as dependency management across different environments, and the deploy process, setting up is pretty complicated. I had to look through different references and the Nix matrix channel just to find a description of an attribute. Things aren\u0026rsquo;t as well-documented but there\u0026rsquo;s a lot of community effort to make this less painful.\nEdit (April 24, 2022): Turns out that it actually isn\u0026rsquo;t a static binary, and I\u0026rsquo;ve modified the post accordingly. The upside is building the Docker image via Nix with emojied in it means it\u0026rsquo;s somewhat irrelevant to require it to be a static binary to begin with. But it does mean I can\u0026rsquo;t easily distribute it outside nix, which is a bummer. Maybe I\u0026rsquo;ll hunt for a workaround in the future. Right now, I\u0026rsquo;m not too keen into sinking a lot of time into something I won\u0026rsquo;t benefit from.\n","permalink":"https://blog.sekun.dev/posts/create-rust-binaries-and-docker-images-with-nix/","summary":"Introduction A few days ago, I released the abomination of a project called emojied (website, repo) to the world. It went great, I\u0026rsquo;m glad people found it funny. However, I\u0026rsquo;m not too pleased with the deployment process: from building the project to shipping it. I made heavy use of Docker to build the necessary static assets, and binary.\nHere\u0026rsquo;s the current setup:\n Dev environment  PostgreSQL (handled by NixOS) rustc, openssl, cargo, etc.","title":"Create Rust binaries, and Docker images with Nix"},{"content":"So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.\n Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ✨ reviews:\n \u0026ldquo;Thanks, I hate it.\u0026rdquo; \u0026ndash; Pay08, 2022\n  \u0026ldquo;downvoted for being a menace to society.\u0026rdquo; \u0026ndash; MultiplyAccumulate, 2022\n  \u0026ldquo;blursed \u0026quot; \u0026ndash; Jaxius3\n  \u0026ldquo;“Made with regret.” Hahahaha. Excellent.\u0026rdquo; \u0026ndash; IronWhiskers, 2022\n  \u0026ldquo;What is wrong with you?\u0026rdquo; \u0026ndash; Jeff\n   That\u0026rsquo;s a lot of people disgusted by what I made\n  Here are some of the things I learned from building a simple project.\nTech Stack After looking around, I decided to go with the following:\n axum (web server) maud (HTML templates via Rust macros) postgres (persistent data storage and business logic) sqitch (database schema migration tool) typescript (you know what this is) docker (\u0026ldquo;simple\u0026rdquo; deploys) nix (reproducible environments)  PostgreSQL Procedures Procedures are extremely cool although this isn\u0026rsquo;t exactly new to me. I\u0026rsquo;ve been experimenting with this in one of my previous, unfinished projects called GNAWEX 1 (One day I will finish it don\u0026rsquo;t you worry).\nThis allows you to implement some business logic in SQL, without having to implement it in the application level. If ever PostgreSQL is a constant in your project, and intend to rewrite the app from scratch, you might just end up having to rewrite the glue rather than your business logic. emojied isn\u0026rsquo;t doing anything too exciting though, so I can\u0026rsquo;t really demonstrate all that is cool about it.\nOkay, an example would be fetching a URL given an identifier, and incrementing the clicks column by one. Here\u0026rsquo;s an example of a procedure that does exactly that:\nCREATE FUNCTION app.get_url(query TEXT) -- ^ This contains the emoji sequence `identifier`  RETURNS TEXT LANGUAGE sql AS $$ -- Considered as a \u0026#34;clicked\u0026#34; link whenever this gets triggered  UPDATE app.links SET clicks = clicks + 1 WHERE links.identifier = $1; -- Builds the URL so that I don\u0026#39;t have to do this in the web server  SELECT concat(scheme, \u0026#39;://\u0026#39;, hosts.name, path) AS url FROM app.links JOIN app.hosts ON links.host = hosts.host_id WHERE links.identifier = $1; $$; It\u0026rsquo;s a simple function that uses SQL as the language that expects any TEXT, and returns a TEXT as well, which is a sequence of emojis, and the URL it maps to respectively. Since whatever happens in this procedure is in the same transaction as what called it, e.g (SELECT * FROM app.get_url('🍊🌐')), if any of this fails, then it rolls back everything, including the incrementing of clicks. If this was at the application level, I\u0026rsquo;d have to reach for whatever transaction implementation it uses (like Ecto.Multi) which doesn\u0026rsquo;t make sense in this case cause Postgres already natively supports transactions.\nI try to make heavy use of stored procedures as long as it\u0026rsquo;s applicable. Inserting to multiple tables with one function, fetching leaderboard entries, etc.\nError handling with implicit From\u0026lt;T\u0026gt; Error handling is pretty nice with Rust, especially since I was never a fan of exceptions since it made control flow so weird. Although that may be because I never really invested that much time working with them. In Rust, I like that you can do two things for errors: errors encoded as ADTs, or panic (unrecoverable). Although I\u0026rsquo;m not entirely sure if all errors can be encoded in sum types, and what can be done if ever one needs to recover from a panic. But for emojied, I definitely don\u0026rsquo;t have to think about that.\nWhat I did have to deal with was finding a more convenient way when dealing with other Error types. For instance, there\u0026rsquo;s tokio_postgres::Error, then there\u0026rsquo;s env::VarError, and if I need to bubble up these errors to the binary, I\u0026rsquo;m gonna need a convenient enough way to do that otherwise I\u0026rsquo;m gonna have a difficult time.\nLet\u0026rsquo;s say I have two errors, a database one, and an application one.\nenum AppError { Foo, Baz } enum DbError { FailedToConnect, InvalidTLSCert } fn some_db_action() -\u0026gt; Result\u0026lt;String, DbError\u0026gt; { Err(DbError::FailedToConnect) } fn some_app_action() -\u0026gt; Result\u0026lt;String, AppError\u0026gt; { let result1 = some_db_action()?; let result2 = some_db_action()?; Ok(result1) } This fails to compile, here\u0026rsquo;s what rustc says:\nerror[E0277]: `?` couldn't convert the error to `AppError` | 212 | fn app_action() -\u0026gt; Result\u0026lt;String, AppError\u0026gt; { | ------------------------ expected `AppError` because of this 213 | let result1 = db_action()?; 214 | let result2 = db_action()?; | ^ the trait `From\u0026lt;url::DbError\u0026gt;` is not implemented for `AppError` | = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `Fro m` trait = note: required because of the requirements on the impl of `FromResidual\u0026lt;Result\u0026lt;Infallible, url::DbError\u0026gt;\u0026gt;` for `Result\u0026lt;std::string::String, AppError\u0026gt;` For more information about this error, try `rustc --explain E0277`. So it tells me that using ? implicitly converts DbError to AppError via the From trait. And because I do not have a trait instance like impl From\u0026lt;DbError\u0026gt; for AppError, it fails.\nAnother thing is I somehow need to bubble up DbError up to the application error somehow. The method I ended up using is to just add a field to the AppError record. It\u0026rsquo;s a bit tiring to copy all the DbError variants over to the AppError enum. I mean, it\u0026rsquo;s fine for this one since it doesn\u0026rsquo;t have that many, but it becomes.\nenum AppError { DbError(DbError), // Hooray!  Foo, Baz } And then I can create a From\u0026lt;DbError\u0026gt; instance:\nimpl From\u0026lt;DbError\u0026gt; for AppError { fn from(e: DbError) -\u0026gt; Self { AppError::DbError(e) } } Which compiles!\nIf I wanted to avoid From, I could do this:\nlet result1 = db_action().map_err(|_| AppError::Foo)?; Except it\u0026rsquo;s kinda annoying cause I have to do this at every call site. Although there are times when I did end up using this.\nApplication configuration While convenient, I can\u0026rsquo;t just hard-code everything into the application, especially for a public project. There are a lot of sensitive data like certs, and sometimes it\u0026rsquo;s just more convenient for whoever is using the application to change stuff without touching the source code. In my case, I had to make it flexible enough to change database credentials.\n A common way to do it is through environment variables.\ne.g PG__HOST=\u0026quot;db.example.com\u0026quot; emojied. So whenever I need to update stuff, all I have to do is just change the environment variable, and I\u0026rsquo;m spared from touching the source code!\n Here\u0026rsquo;s emojied\u0026rsquo;s config for it to run:\npub struct AppConfig { /// Application host  pub host: String, /// PostgreSQL config  pub pg: tokio_postgres::Config, /// Pool manager config  pub manager: ManagerConfig, /// Pool size  pub pool_size: usize, pub ca_cert_path: Option\u0026lt;String\u0026gt;, } Then I created an associated function for it called from_env/0 which returns a Result\u0026lt;AppConfig, Error\u0026gt;. I\u0026rsquo;ll talk about the Error part in the Error Handling section. Then I can use Rust\u0026rsquo;s std::env module to get a var\u0026rsquo;s value!\nHere\u0026rsquo;s a tiny example:\nuse std::env; struct AppConfig { pg_host: String, } impl AppConfig { fn from_env() -\u0026gt; Result\u0026lt;AppConfig, Error\u0026gt; { let host = env::var(\u0026#34;PG__HOST\u0026#34;)?; Ok(AppConfig { pg_host: host }) } }  Side note: This kinda looks monadic, where it binds AppConfig to host, and evaluates to Error and \u0026ldquo;exits\u0026rdquo; otherwise.\n Handling database\u0026hellip;handler in axum I created this database handle that has all the things I need to communicate with the database server:\npub struct Handle { pub pool: Pool, } It\u0026rsquo;s pretty simple. It\u0026rsquo;s a struct that has a pool field. Then I created two more functions to make things more convenient: new/1, and client/1.\nnew(config: AppConfig) -\u0026gt; Result\u0026lt;Handle, Error\u0026gt; expects an AppConfig as an argument, and if all goes well, then a new database handle with all the important things in it. client(\u0026amp;self) -\u0026gt; Result\u0026lt;Pool, Error\u0026gt; expects a reference to self, which is Handle in this case. This uses the DB pool to create a new client. From this client, you can do DB queries with it.\n// Grabs a client from the pool let client = handle.client().await?; // Runs a query that gets a URL\u0026#39;s stats let data = client .query(\u0026#34;SELECT * FROM app.get_url_stats($1)\u0026#34;, \u0026amp;[\u0026amp;identifier]) .await?; // Manually maps the row to a leaderboard entry let db_id = data[0].try_get(0)?; let db_clicks = data[0].try_get(1)?; let db_url = data[0].try_get(2)?; Ok(leaderboard::Entry { identifier: db_id, clicks: db_clicks, url: db_url, }) Okay, so I somehow need access to the database handle in the \u0026ldquo;controllers\u0026rdquo;, like in controllers::leaderboard.\n I\u0026rsquo;m only calling it a controller since it\u0026rsquo;s a common concept. axum doesn\u0026rsquo;t call it that.\n let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)); axum recommends 2 mentions that you could use \u0026ldquo;request extensions\u0026rdquo; which looks like it acts like middleware. It recommends to have Arc inhabit Extension (Extension\u0026lt;Arc\u0026lt;T\u0026gt;\u0026gt;), but why?\nTime to do it in some wrong ways. This is fine since rustc is quite helpful with its error messages.\nI\u0026rsquo;ll try to move handle instead:\nuse axum::{extract::Extension, routing::get, Router}; use std::net::SocketAddr; pub async fn run(handle: db::Handle) -\u0026gt; Result\u0026lt;(), hyper::Error\u0026gt; { let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await } Doing that gives me this error:\nerror[E0277]: the trait bound `db::Handle: Clone` is not satisfied --\u0026gt; src/lib.rs:36:16 | 36 | .layer(Extension(handle)); | ----- ^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `db::Handle` | | | required by a bound introduced by this call | = note: required because of the requirements on the impl of `tower_layer::Layer\u0026lt;Route\u0026lt;_\u0026gt;\u0026gt;` for `Extension\u0026lt;db:: Handle\u0026gt;` For more information about this error, try `rustc --explain E0277`. It seems like I need to derive Clone for db::Handle since it probably gets cloned every time, although I\u0026rsquo;m not sure exactly when it does get cloned. In every new request?\nSo what happens if I do derive Clone?\n#[derive(Clone)] struct Handle { pub pool: Pool } Then I need to make sure that the function\u0026rsquo;s type signature matches:\npub async fn leaderboard( Extension(handle): Extension\u0026lt;db::Handle\u0026gt; // ^ Here! axum seems to know exactly where to apply it to the args. Not sure  // how this is done (yet). ) -\u0026gt; (StatusCode, Markup) { match leaderboard::fetch(\u0026amp;handle).await { Ok(entries) =\u0026gt; { (StatusCode::OK, views::leaderboard::render(entries)) }, Err(_e) =\u0026gt; (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}), } } Well, it seems to compile just fine. The leaderboard page works fine as well. I don\u0026rsquo;t really have that much experience with this yet but my current assumption is that I\u0026rsquo;m required to derive Clone for Handle since there\u0026rsquo;s no way to do shared ownership. So what it does is that it ends up cloning it every time. But, what if I don\u0026rsquo;t want to clone it? What if I just pass around references?\npub async fn run(handle: db::Handle) -\u0026gt; Result\u0026lt;(), hyper::Error\u0026gt; { let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(\u0026amp;handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await Compiles with this helpful error message:\nerror[E0597]: `handle` does not live long enough --\u0026gt; src/lib.rs:36:26 | 22 | let app = Router::new() | _______________- 23 | | .route(\u0026quot;/leaderboard\u0026quot;, routing::get(controllers::leaderboard)) 24 | | .layer(Extension(\u0026amp;handle)); | |__________________________^^^^^^^_- argument requires that `handle` is borrowed for `'static` | | | borrowed value does not live long enough ... 44 | } | - `handle` dropped here while still borrowed For more information about this error, try `rustc --explain E0597`. Unfortunately, I\u0026rsquo;m not too familiar with how lifetimes work in async/await. But it looks like since it\u0026rsquo;s non-blocking, handle gets dropped since the function reaches the end of its scope while the server is still running.\n This is all just somewhat smart guessing though. I\u0026rsquo;m gonna need to do more reading on this topic.\n Wait, what about app then? Won\u0026rsquo;t this get dropped as well? I wanted to confirm if this did get moved, or if it did some other trickery I had no idea about:\nlet app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(handle)); let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); let foo = axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await; println!(\u0026#34;{:?}\u0026#34;, app); foo So if app does get moved, then rustc should complain about me accessing a variable with no ownership; which it does:\nerror[E0382]: borrow of moved value: `app` --\u0026gt; src/lib.rs:46:22 | 22 | let app = Router::new() | --- move occurs because `app` has type `Router`, which does not implement the `Copy` trait ... 42 | .serve(app.into_make_service()) | ------------------- `app` moved due to this method call ... 46 | println!(\u0026#34;{:?}\u0026#34;, app); | ^^^ value borrowed here after move | note: this function takes ownership of the receiver `self`, which moves `app` Phew! It\u0026rsquo;s almost like I\u0026rsquo;m encouraged to try out all the failed scenarios to learn a lot of things since the compiler is quite helpful.\nOkay, since I didn\u0026rsquo;t want this to get cloned all the time, I will just follow what axum used in its examples - the usage of Arc\u0026lt;T\u0026gt;:\npub async fn run(handle: db::Handle) -\u0026gt; Result\u0026lt;(), hyper::Error\u0026gt; { let handle = Arc::new(handle); // ^ Shadow previous binding with `Arc\u0026lt;db::Handle\u0026gt;`  let app = Router::new() .route(\u0026#34;/leaderboard\u0026#34;, routing::get(controllers::leaderboard)) .layer(Extension(handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026amp;addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await } And then I\u0026rsquo;ll remove the Clone derivation:\npub struct Handle { pub pool: Pool, } So if I\u0026rsquo;m not mistaken, which I probably am, Arc\u0026lt;T\u0026gt; should allow me to share ownership of db::Handle without having to clone it 3.\npub async fn leaderboard( Extension(handle): Extension\u0026lt;Arc\u0026lt;db::Handle\u0026gt;\u0026gt; ) -\u0026gt; (StatusCode, Markup) { match leaderboard::fetch(\u0026amp;*handle).await { Ok(entries) =\u0026gt; { (StatusCode::OK, views::leaderboard::render(entries)) }, Err(_e) =\u0026gt; (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}), } } Then in leaderboard::fetch/1:\npub async fn fetch_url( handle: \u0026amp;db::Handle, identifier: String ) -\u0026gt; Result\u0026lt;String, Error\u0026gt; { let client = handle.client().await?; let row = client .query_one(\u0026#34;SELECT app.get_url($1)\u0026#34;, \u0026amp;[\u0026amp;identifier]) .await?; row.try_get(0).map_err(|e| Error::from(e)) } Although, I had to manually dereference it to get the reference to Handle. It\u0026rsquo;s also a good thing that I don\u0026rsquo;t have to mutate handle at all because otherwise this would\u0026rsquo;ve been a more painful experience.\nConnecting to a managed database Initially, I used sqlx as the db library since it gets recommended in almost every post about SQL libraries on the Rust subreddit. It worked fine for me until I had to get it to connect to DO\u0026rsquo;s managed DB. It required me to connect to it via TLS, and it wasn\u0026rsquo;t a pleasant experience trying to debug what\u0026rsquo;s wrong with sqlx, so I ditched it settled with tokio-postgres, deadpool-postgres, and native-tls. Oh, I also had a difficult time 4 with rustls since it didn\u0026rsquo;t seem to like DO\u0026rsquo;s CA certificate, which is why I settled with native-tls.\nnative-tls needed OpenSSL setup, which I was able to do with Nix (for the dev environment):\n# ... devShell = pkgs.mkShell { # inherit (self.checks.${system}.pre-commit-check) shellHook; buildInputs = with pkgs; [ # Back-end pkgs.rustc pkgs.cargo pkgs.openssl pkgs.pkg-config ]; PKG_CONFIG_PATH = \u0026#34;${pkgs.openssl.dev}/lib/pkgconfig\u0026#34;; }; # ... So I had to provide the CA cert during runtime, not build-time since: 1) it\u0026rsquo;ll be easier to distribute the static binary and Docker image, and 2) some CA certs are only given during runtime (like DO if ever you\u0026rsquo;re using app platform). This was my process:\n Build static binary \u0026amp; image without CA certs and other DB secrets When the image runs, it\u0026rsquo;s assumed that the necessary environment variables, like one that contains the certificate contents, exist. Write the certificate contents to a file. Run emojied  This seems to be a pretty standard process, although this is fairly tedious.\n// src/config.rs use tokio_postgres::config::SslMode; let mut pg_config = tokio_postgres::Config::new(); // I also read other PG values like hostname, DB name, user, etc. but excluded // those for brevity.  // Not providing CA_CERT is fine let ca_cert_path = match env::var(\u0026#34;PG__CA_CERT\u0026#34;) { Ok(path) =\u0026gt; { // I think `Prefer` is fine as well, which is the default  // for `tokio-postgres`.  pg_config.ssl_mode(SslMode::Require); Some(path) }, Err(_e) =\u0026gt; { None } }; I allowed it to continue running without the cert path in PG__CA_CERT for dev environments.\n// Somewhere in src/db.rs  let manager = match app_config.ca_cert_path { Some(ca_cert_path) =\u0026gt; { // Read file into byte vector  let cert = std::fs::read(ca_cert_path) .map_err(|e| Error::CACertFileError(e))?; // Create a certificate from a PEM file  let ntls_cert = Certificate::from_pem(\u0026amp;cert) .map_err(|_| Error::InvalidCACert)?; let tls = TlsConnector::builder() .add_root_certificate(ntls_cert) .build() .map_err(|_| Error::FailedToBuildTlsConnector)?; let conn = MakeTlsConnector::new(tls); Manager::from_config(app_config.pg, conn, app_config.manager) } None =\u0026gt; Manager::from_config(app_config.pg, NoTls, app_config.manager), }; // Since we need a `manager` to build a pool let pool = Pool::builder(manager) .max_size(app_config.pool_size) .build() .map_err(|_| Error::FailedToBuildPool)?;  The process was quite similar with SQLx but there was something, that I don\u0026rsquo;t really remember anymore, which made it so frustrating to work with.\n Unfortunately, DO doesn\u0026rsquo;t support multiline environment variables, for some reason, so cramming everything including the BEGIN CERTIFICATE and END CERTIFICATE into one line resulted in it getting rejected. So, I just got what\u0026rsquo;s in between, and manually appended it to the file instead.\necho \u0026#34;Dumping CA certificate to /app/ca-certificate.crt\u0026#34; echo \u0026#34;-----BEGIN CERTIFICATE-----\u0026#34; \u0026gt; /app/ca-certificate.crt echo $CA_CERT \u0026gt;\u0026gt; /app/ca-certificate.crt echo \u0026#34;-----END CERTIFICATE-----\u0026#34; \u0026gt;\u0026gt; /app/ca-certificate.crt echo \u0026#34;Executing emojied\u0026#34; ./emojied Kind of hacky, and inconvenient especially if I forget. But it works!\nURL redirect woes This is a short one. For the redirect, I returned an HTTP status 301 5 with a response containing the URL to redirect to. So the process goes something like this:\n Enter https://emojied.net/🍊🌐 in the browser. emojied looks for an entry with 🍊🌐, and gets the associated URL. Respond with an HTTP 301 and the URL Browser automatically performs the redirect  Unfortunately, and I spent 30mins on this scratching my head why this was happening, the request would get cached, and this is bad! It\u0026rsquo;s bad because I had to increment the clicks column every time the link is visited. But if it\u0026rsquo;s cached, then the server won\u0026rsquo;t bother to call the functions it needs to call!\nThen, I found out that 301 gets cached automatically by the browser 6, and that I needed to use 302.\nHTML templating with maud I had a pleasant experience with server-side templating while I was building a Haskell project called Swoogle. I used lucid 7 which was a pretty darn elegant HTML DSL.\n-- Category options select_ [ id_ \u0026#34;category-options\u0026#34; , name_ \u0026#34;resource\u0026#34; , class_ \u0026#34;bg-white font-semibold dark:bg-su-dark-bg-alt text-su-fg dark:text-su-dark-fg\u0026#34; , required_ \u0026#34;required\u0026#34; ] $ do option_ [disabled_ \u0026#34;disabled\u0026#34;, selected_ \u0026#34;selected\u0026#34;, value_ \u0026#34;\u0026#34;] \u0026#34;Category\u0026#34; option_ [value_ \u0026#34;people\u0026#34;] \u0026#34;People\u0026#34; option_ [value_ \u0026#34;film\u0026#34;] \u0026#34;Film\u0026#34; option_ [value_ \u0026#34;starship\u0026#34;] \u0026#34;Starship\u0026#34; option_ [value_ \u0026#34;vehicle\u0026#34;] \u0026#34;Vehicle\u0026#34; option_ [value_ \u0026#34;species\u0026#34;] \u0026#34;Species\u0026#34; option_ [value_ \u0026#34;planet\u0026#34;] \u0026#34;Planet\u0026#34; Well, I wanted something like that in Rust, and I found maud 8. I did run into a problem when I tried to use its latest version with axum since something must\u0026rsquo;ve changed in axum, so I had to pull from the main instead:\n[dependencies] ... maud = { git = \u0026quot;https://github.com/lambda-fairy/maud\u0026quot;, branch = \u0026quot;main\u0026quot;, features = [\u0026quot;axum\u0026quot;] } ... So with this, I could do stuff like:\nfn foo() -\u0026gt; Markup { html! { (\u0026#34;Hello\u0026#34;) h1 class=\u0026#34;text-red-500\u0026#34; { (\u0026#34;Hello!\u0026#34;) } h2 class=(\u0026#34;font-semibold\u0026#34;) { (\u0026#34;Hey\u0026#34;) } } } \u0026lt;noscript\u0026gt; tag, and problems with JS toggling extensions I wanted to have the website work with JS disabled because, well, it was a very simple website. There was no reason why I couldn\u0026rsquo;t make all the important features work without JS!\nSo I ended up making heavy use of the \u0026lt;noscript\u0026gt; tag, since it allowed me to display alternative content when the browser has JS disabled. You\u0026rsquo;ll see it littered all over the codebase, like so:\n@match data { RootData::Auto(_) =\u0026gt; { noscript { div class=\u0026#34;w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1\u0026#34; { a href=\u0026#34;?custom_url=t\u0026#34; type=\u0026#34;button\u0026#34; class=\u0026#34;font-medium underline\u0026#34; { \u0026#34;Custom URL\u0026#34; } } } } RootData::Custom(_) =\u0026gt; { noscript { div class=\u0026#34;w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1\u0026#34; { a href=\u0026#34;/\u0026#34; type=\u0026#34;button\u0026#34; class=\u0026#34;font-medium underline\u0026#34; { \u0026#34;Autogenerate a custom URL for me\u0026#34; } } } } } These only get rendered by the browser when JS is disabled. But what do browser extensions like NoScript when it \u0026ldquo;disables\u0026rdquo; JS? It\u0026rsquo;s something like this:\n Block requests for JS files via CSP (Content Security Policies) Replace noscript tags to span or div tags  The problem I ended up with was in #2. Why? Because the noscript tag attributes weren\u0026rsquo;t copied over to the new span/div tags. And that breaks a lot of stuff.\nSo while emojied does work without JS, it won\u0026rsquo;t work due to how the extensions work 9.\nConclusion Alright, that was a lot. I did learn a lot from this experience. I actually only read until chapter 10 of the Rust Book, and skipped to some parts like advanced traits, and other things. I really like the fact that there\u0026rsquo;s a detailed book that talks about some idiomatic Rust patterns, and even the more advanced stuff, that\u0026rsquo;s completely FREE. How crazy is that? My wallet is spared!\nI usually try to avoid failure, even in Haskell, cause its error messages are pretty bad. When I started out, it was pretty much worthless to read GHC\u0026rsquo;s error messages since it would just confuse me even more. It was only until I had people guide me (like justosophy, thank you) that I slowly got to understand what GHC was trying to tell me. With Rust though, it\u0026rsquo;s a completely different experience.\nI like failing because Rust is very helpful with its error messages. In fact, I discover new things by reading it so I\u0026rsquo;m not punished for trying out different things that don\u0026rsquo;t work just to gain more insight.\nI also like that it\u0026rsquo;s fairly easy on resources. I didn\u0026rsquo;t even bother optimizing this at all since I mostly have no idea what I\u0026rsquo;m doing, and I\u0026rsquo;m trying to avoid having to deal with lifetimes as much as possible. I\u0026rsquo;m hosting this on a 1x shared vCPU + 512MB RAM, and it didn\u0026rsquo;t break a sweat during peak load.\nAnyway, so far, so good! I\u0026rsquo;m pretty ecstatic to continue learning Rust.\n  https://github.com/gnawex/gnawex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://docs.rs/axum/0.5.1/axum/#using-request-extensions\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://doc.rust-lang.org/std/sync/struct.Arc.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://hackage.haskell.org/package/lucid\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/lambda-fairy/maud\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/hackademix/noscript/issues/238\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://blog.sekun.dev/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/","summary":"So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.\n Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ✨ reviews:","title":"What I learned from building an emoji URL shortener in Rust"},{"content":"Here\u0026rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn\u0026rsquo;t have the version you want. Fortunately, there\u0026rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?\nNone of em! I don\u0026rsquo;t want to maintain any bash scripts to do that. I just want to load up the Nix environment, and start.\nThat was pretty much what I ran into today, I wanted to have postgrest in my Nix environment so I hopped on nixpkgs search, only to find that the existing versions are quite old, as well as having to build the project from source. Which I didn\u0026rsquo;t want to do due to my limited LTE bandwidth. Why should I? postgrest has pre-built, static binaries in its GitHub releases page. Is there any way I can make use of that instead? And that\u0026rsquo;s what I set off to do today.\ntl;dr: Binaries are built, me copy. Me save mobile data. Happy.\n Disclaimer: I\u0026rsquo;m a Nix newbie.\n Setup I need to import the postgrest flake to an existing flake of another project. The project\u0026rsquo;s directory has a nix folder for all the packages that don\u0026rsquo;t exist in nixpkgs, like so:\nnix └── postgrest ├── flake.lock └── flake.nix The flake.lock gets automatically generated by Nix when it finds out that it doesn\u0026rsquo;t exist yet when running nix build; no need to create that. Here\u0026rsquo;s the starting flake.nix:\n{ description = \u0026#34;REST API for any Postgres database\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; }; outputs = {self, nixpkgs}: { }; } A basic flake file has a set of inputs and outputs. The output here will be the postgrest package.\nTime to throw the binary in Nix.\nI have no idea how to build things in flakes, so consulting the wiki is pretty much a requirement 1! It covers things like how to enable flakes, and I won\u0026rsquo;t bother covering because I\u0026rsquo;ll only make a worse version of it.\nIt tells me about both the inputs and outputs schema. But because I only need nixpkgs for this one, there\u0026rsquo;s not much else for me to add to the inputs.\nHere\u0026rsquo;s the output schema:\n{ self, ... }@inputs: { # Executed by `nix flake check` checks.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Executed by `nix build .#\u0026lt;name\u0026gt;` packages.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Executed by `nix build .` defaultPackage.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = derivation; # Executed by `nix run .#\u0026lt;name\u0026gt;` apps.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = { type = \u0026#34;app\u0026#34;; program = \u0026#34;\u0026lt;store-path\u0026gt;\u0026#34;; }; # Executed by `nix run . -- \u0026lt;args?\u0026gt;` defaultApp.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = { type = \u0026#34;app\u0026#34;; program = \u0026#34;...\u0026#34;; }; # Used for nixpkgs packages, also accessible via `nix build .#\u0026lt;name\u0026gt;` legacyPackages.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Default overlay, consumed by other flakes overlay = final: prev: { }; # Same idea as overlay but a list or attrset of them. overlays = {}; # Default module, consumed by other flakes nixosModule = { config }: { options = {}; config = {}; }; # Same idea as nixosModule but a list or attrset of them. nixosModules = {}; # Used with `nixos-rebuild --flake .#\u0026lt;hostname\u0026gt;` # nixosConfigurations.\u0026#34;\u0026lt;hostname\u0026gt;\u0026#34;.config.system.build.toplevel must be a derivation nixosConfigurations.\u0026#34;\u0026lt;hostname\u0026gt;\u0026#34; = {}; # Used by `nix develop` devShell.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = derivation; # Used by `nix develop .#\u0026lt;name\u0026gt;` devShells.\u0026#34;\u0026lt;system\u0026gt;\u0026#34;.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = derivation; # Hydra build jobs hydraJobs.\u0026#34;\u0026lt;attr\u0026gt;\u0026#34;.\u0026#34;\u0026lt;system\u0026gt;\u0026#34; = derivation; # Used by `nix flake init -t \u0026lt;flake\u0026gt;` defaultTemplate = { path = \u0026#34;\u0026lt;store-path\u0026gt;\u0026#34;; description = \u0026#34;template description goes here?\u0026#34;; }; # Used by `nix flake init -t \u0026lt;flake\u0026gt;#\u0026lt;name\u0026gt;` templates.\u0026#34;\u0026lt;name\u0026gt;\u0026#34; = { path = \u0026#34;\u0026lt;store-path\u0026gt;\u0026#34;; description = \u0026#34;\u0026#34;; }; } That\u0026rsquo;s a lot.\noutputs is a lambda with a set as its argument. Since nix functions can only have one argument, putting the stuff you need in a set is how you get around that restriction. {self, ...} is some form of pattern matching the fields in a set, and @inputs binds the set to input. Cool. The latter isn\u0026rsquo;t that useful to me in this scenario though, so I\u0026rsquo;ll omit that. It seems that in every flake outputs, self must be there. I don\u0026rsquo;t understand what self is, but I\u0026rsquo;ll leave that for another time.\nWith the schema, there are two fields that seem important: packages, and defaultPackage. packages would be useful if I wanted to have multiple versions of postgrest available for me to use like postgres-8-0-0 and postgrest-9-0-0, but I don\u0026rsquo;t! I only need the latest version, which is 9.0.0 at the time of writing. So we can ignore that, and I\u0026rsquo;ll use defaultPackage instead.\nHere\u0026rsquo;s what we have so far:\n{ description = \u0026#34;REST API for any Postgres database\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; }; outputs = {self, nixpkgs}: { defaultPackage.x86_64-linux = with import nixpkgs { system = \u0026#34;x86_64-linux\u0026#34;; }; stdenv.mkDerivation rec { name = \u0026#34;postgrest-${version}\u0026#34;; version = \u0026#34;9.0.0\u0026#34;; # I still lack stuff here! }; }; } with import nixpkgs {system = \u0026quot;x86_64-linux\u0026quot;}; spares me from having to qualify everything like nixpkgs.system.\u0026quot;x86_64\u0026quot;.stdenv.mkDerivation which is handy 2. This brings stdenv into scope, and has mkDerivation which, from the name, makes a derivation; something I need for defaultPackage.\u0026lt;system\u0026gt;. Unfortunately, I couldn\u0026rsquo;t find any official documentation for mkDerivation that specifies every single field usable in it. Maybe it exists and that I just suck at Googling. That is definitely possible. There are some examples 3, especially in the wild.\nrec allows me to refer to the set\u0026rsquo;s own fields within it. I\u0026rsquo;m using the field version and interpolated it in name!\nAlright that\u0026rsquo;s it for the setup. Time to fetch the binary.\nFetching the binary The wiki has an example for fetching stuff from a URL, and using it in mkDerivation 4.\nsrc = fetchurl { url = \u0026#34;https://download.studio.link/releases/v${version}-stable/linux/studio-link-standalone-v${version}.tar.gz\u0026#34;; sha256 = \u0026#34;sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=\u0026#34;; }; So it looks like I need two things, a url which can be a tar file, and a sha256. The sha256 field is used to make something impure a little bit less unpredictable. If the release were somehow to change under the same name, then it would fail cause the SHA would have a different signature.\nBut\u0026hellip; how does one get the SHA? A trick is to just leave it blank. Nix will inform you and make a comparison of the expected vs actual signature.\nAdd this in the outputs schema:\nsrc = pkgs.fetchurl { # Remember `rec`! url = \u0026#34;https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\u0026#34;; sha256 = \u0026#34;\u0026#34;; }; and run nix build in the directory with this flake.nix file.\nsekun@nixos ~/P/g/n/postgrest (feature/postgrest)\u0026gt; nix build warning: Git tree '/home/sekun/Projects/gnawex' is dirty warning: found empty hash, assuming 'sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=' error: hash mismatch in fixed-output derivation '/nix/store/mag8ly8f0rlw5dqxj7ir8maa1bqgkyxv-postgrest-v9.0.0-linux-static-x64.tar.xz.drv': specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= got: sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4= error: 1 dependencies of derivation '/nix/store/yg6adsask3s2sg636m5dwy0c79dadg9g-postgrest-9.0.0.drv' failed to build sekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1]\u0026gt; It does fail, as expected. This is how it\u0026rsquo;ll be if ever the signature were to change. But there it is! It tells us what we specified, and what Nix got. So let\u0026rsquo;s yoink that and slap it in the schema.\nsrc = pkgs.fetchurl { url = \u0026#34;https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\u0026#34;; sha256 = \u0026#34;sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=\u0026#34;; }; Now that we have the binary, all that\u0026rsquo;s left is to install it.\nInstalling Going back to the example in 4:\nstdenv.mkDerivation rec { name = \u0026#34;studio-link-${version}\u0026#34;; version = \u0026#34;21.07.0\u0026#34;; src = fetchurl { url = \u0026#34;https://download.studio.link/releases/v${version}-stable/linux/studio-link-standalone-v${version}.tar.gz\u0026#34;; sha256 = \u0026#34;sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=\u0026#34;; }; nativeBuildInputs = [ autoPatchelfHook ]; buildInputs = [ alsaLib openssl zlib pulseaudio ]; sourceRoot = \u0026#34;.\u0026#34;; installPhase = \u0026#39;\u0026#39; install -m755 -D studio-link-standalone-v${version}$out/bin/studio-link \u0026#39;\u0026#39;; meta = with lib; { homepage = \u0026#34;https://studio-link.com\u0026#34;; description = \u0026#34;Voip transfer\u0026#34;; platforms = platforms.linux; }; } We can ignore nativeBuildInputs and buildInputs since those are used for declaring what dependencies should be there when building something. In this case, there\u0026rsquo;s nothing to build because we just got a pre-built binary. Nor do we have to provide any runtime dependencies because it\u0026rsquo;s a static binary. That leaves sourceRoot, installPhase, and meta left. I tried looking for more information about sourceRoot found some explanations but I was left unsure if I needed it. Let\u0026rsquo;s leave that out for now. We do need installPhase since we have to send it off to the Nix store. It looks like I can reuse this without much changes.\ninstallPhase = '' install -m755 -D postgrest $out/bin/postgrest ''; I have no idea what install is. And as usual, check the manual/wiki! The manual description tells me it\u0026rsquo;s how one copies files while setting attributes. -m755 sets the permissions to 755, postgrest is the source, and $out/bin/postgrest is the target. $out is set by Nix, which points to the Nix store with the package\u0026rsquo;s name for the folder. Alright, cool!\nTime to run nix build again to see if this works.\n\u0026hellip;and it doesn\u0026rsquo;t.\nsekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1]\u0026gt; nix build warning: Git tree '/home/sekun/Projects/gnawex' is dirty error: builder for '/nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv' failed with exit code 1; last 3 log lines: \u0026gt; unpacking sources \u0026gt; unpacking source archive /nix/store/644yqp1y3cgw45qfqsbxb013hm4r2zw6-postgrest-v9.0.0-linux-static-x64.tar.xz \u0026gt; unpacker appears to have produced no directories For full logs, run 'nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv'. The error seems to point out that it couldn\u0026rsquo;t unpack the tar anywhere. Running nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv seems to tell me the same thing.\nAlright alright, let\u0026rsquo;s take a look at what the manual has to say about sourceRoot:\n After running unpackPhase, the generic builder changes the current directory to the directory created by unpacking the sources. If there are multiple source directories, you should set sourceRoot to the name of the intended directory. Set sourceRoot = \u0026ldquo;.\u0026quot;; if you use srcs and control the unpack phase yourself.\n This isn\u0026rsquo;t really so helpful because I\u0026rsquo;m not using srcs, nor am I using unpackPhase, nor am I unpacking multiple sources! I am however specifying a remote file as src with fetchurl, which does seem to unpack it. I have no clue what fetchurl does because the manual doesn\u0026rsquo;t seem to cover it 5. No idea what else to do here so I\u0026rsquo;ll just follow the suggestion of adding sourceRoot \u0026quot;.\u0026quot;. Run nix build again, and see it finally work!\nHere\u0026rsquo;s the final flake:\n{ description = \u0026#34;REST API for any Postgres database\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; }; outputs = {self, nixpkgs}: { defaultPackage.x86_64-linux = with import nixpkgs { system = \u0026#34;x86_64-linux\u0026#34;; }; stdenv.mkDerivation rec { name = \u0026#34;postgrest-${version}\u0026#34;; version = \u0026#34;9.0.0\u0026#34;; # https://nixos.wiki/wiki/Packaging/Binaries src = pkgs.fetchurl { url = \u0026#34;https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\u0026#34;; sha256 = \u0026#34;sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=\u0026#34;; }; sourceRoot = \u0026#34;.\u0026#34;; installPhase = \u0026#39;\u0026#39; install -m755 -D postgrest $out/bin/postgrest \u0026#39;\u0026#39;; meta = with lib; { homepage = \u0026#34;https://postgrest.org\u0026#34;; description = \u0026#34;REST API for any Postgres database\u0026#34;; platforms = platforms.linux; }; }; }; } Importing a local flake to another flake Here\u0026rsquo;s the flake file that needs postgrest:\n{ description = \u0026#34;An independent MouseHunt marketplace\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; masterpkgs.url = \u0026#34;github:NixOS/nixpkgs/master\u0026#34;; flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; }; outputs = { self, nixpkgs, masterpkgs, flake-utils }: flake-utils.lib.eachSystem [ \u0026#34;x86_64-linux\u0026#34; ] (system: let pkgs = nixpkgs.legacyPackages.${system}; postgrest = postgrestPkg.defaultPackage.${system}; lib = nixpkgs.lib; in { devShell = pkgs.mkShell rec { buildInputs = [ masterpkgs.legacyPackages.${system}.pgadmin4 ]; }; }); }  Oh, you don\u0026rsquo;t know what GNAWEX 6 is? Well, it\u0026rsquo;s just an app I\u0026rsquo;ve been working on for a video game I\u0026rsquo;ve been playing for nearly 12 years. I\u0026rsquo;m not addicted, I swear. I\u0026rsquo;m only doing this to learn PostgreSQL\u0026rsquo;s cool features!\n Besides using flake-utils to make handling different \u0026lt;system\u0026gt;s more convenient, the flake does look pretty much the same. Now how does one refer to this local postgrest flake in this flake? Fortunately, the wiki 1 has an example in the inputs schema section:\n# local directories (for absolute paths you can omit \u0026#39;path:\u0026#39;) directory-example.url = \u0026#34;path:/path/to/repo\u0026#34;; We need to keep path: since we need a relative path since the postgrest flake is in ./nix/postgrest/flake.nix. Add this to the flake file that needs it, in its inputs set:\ninputs = { # ... postgrestPkg.url = \u0026#34;path:./nix/postgrest\u0026#34;; }; postgrestPkg can be anything, but I\u0026rsquo;m naming it postgrestPkg to avoid confusion with the actual postgrest package. Then, for convenience, I added this in the let expression:\npostgrest = postgrestPkg.defaultPackage.${system}; This binds postgres-9-0-0 to postgrest, which I use in devShell\u0026rsquo;s buildInputs. Here\u0026rsquo;s the final flake:\n{ description = \u0026#34;An independent MouseHunt marketplace\u0026#34;; inputs = { nixpkgs.url = \u0026#34;github:NixOS/nixpkgs\u0026#34;; masterpkgs.url = \u0026#34;github:NixOS/nixpkgs/master\u0026#34;; postgrestPkg.url = \u0026#34;path:./nix/postgrest\u0026#34;; # New! flake-utils.url = \u0026#34;github:numtide/flake-utils\u0026#34;; }; # V Add this one. Order matters. outputs = { self, nixpkgs, masterpkgs, postgrestPkg, flake-utils }: flake-utils.lib.eachSystem [ \u0026#34;x86_64-linux\u0026#34; ] (system: let pkgs = nixpkgs.legacyPackages.${system}; postgrest = postgrestPkg.defaultPackage.${system}; # For convenience lib = nixpkgs.lib; in { devShell = pkgs.mkShell rec { buildInputs = [ postgrest # A shiny `postgres` package! masterpkgs.legacyPackages.${system}.pgadmin4 ]; }; }); } Now postgrest is available in the shell environment:\ndirenv: loading ~/Projects/gnawex/.envrc direnv: using flake warning: Git tree '/home/sekun/Projects/gnawex' is dirty warning: Git tree '/home/sekun/Projects/gnawex' is dirty direnv: renewed cache direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DETERMINISTIC_BUILD +HOST_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_BUILD_CORES +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_INDENT_MAKE +NIX_LDFLAGS +NIX_STORE +NM +OBJCOPY +OBJDUMP +PYTHONHASHSEED +PYTHONNOUSERSITE +PYTHONPATH +RANLIB +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +_PYTHON_HOST_PLATFORM +_PYTHON_SYSCONFIGDATA_NAME +buildInputs +buildPhase +builder +configureFlags +depsBuildBuild +depsBuildBuildPropagated +depsBuildTarget +depsBuildTargetPropagated +depsHostHost +depsHostHostPropagated +depsTargetTarget +depsTargetTargetPropagated +doCheck +doInstallCheck +dontAddDisableDepTrack +name +nativeBuildInputs +out +outputs +patches +phases +propagatedBuildInputs +propagatedNativeBuildInputs +shell +shellHook +stdenv +strictDeps +system ~PATH ~XDG_DATA_DIRS sekun@nixos ~/P/gnawex (feature/postgrest)\u0026gt; postgrest Usage: postgrest [-e|--example] [--dump-config | --dump-schema] FILENAME PostgREST 9.0.0 / create a REST API to an existing Postgres database Available options: -h,--help Show this help text -e,--example Show an example configuration file --dump-config Dump loaded configuration and exit --dump-schema Dump loaded schema as JSON and exit (for debugging, output structure is unstable) FILENAME Path to configuration file (optional with PGRST_ environment variables) To run PostgREST, please pass the FILENAME argument or set PGRST_ environment variables. If you\u0026rsquo;re wondering how to load the nix shell automatically without running nix develop, look into direnv, and nix-direnv! I\u0026rsquo;ll probably write about that too since it\u0026rsquo;s so damn handy that I can\u0026rsquo;t live without it. It\u0026rsquo;s like virtualenv on crack.\nConclusion Could\u0026rsquo;ve been easier if everything was in the manual. But it isn\u0026rsquo;t so the entire process of figuring it out involved a lot of Google-fu + man + GitHub code search.\nThat\u0026rsquo;s it from me for now. It\u0026rsquo;s a relatively basic thing to do in Nix since this is in many leagues easier than building a project with it. Still useful though since there\u0026rsquo;s a lot of pre-built, static binaries out there.\n  https://nixos.wiki/wiki/Flakes\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://nixos.org/guides/nix-pills/basics-of-language.html#idm140737320525664\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#flake-format\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://nixos.wiki/wiki/Packaging/Binaries\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/NixOS/nix/issues/1489\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n https://github.com/gnawex/gnawex\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://blog.sekun.dev/posts/packaging-prebuilt-binaries-with-nix/","summary":"Here\u0026rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn\u0026rsquo;t have the version you want. Fortunately, there\u0026rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?","title":"Packaging Pre-built Binaries with Nix Flake"}]