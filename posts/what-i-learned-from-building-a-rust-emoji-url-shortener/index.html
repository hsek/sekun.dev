<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>What I learned from building an emoji URL shortener in Rust | sekun's blog</title>
<meta name=keywords content="nix,postgresql,rust,axum">
<meta name=description content="So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.
 Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:">
<meta name=author content="sekun">
<link rel=canonical href=https://blog.sekun.dev/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Vollkorn:wght@400;500;600;700&display=swap" rel=stylesheet>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c5fdf02d9fbdbf20a5d2f0688981e299eed4e35afd7c8b5989b9d6c8f9944a14.css integrity="sha256-xf3wLZ+9vyCl0vBoiYHime7U41r9fItZibnWyPmUShQ=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.sekun.dev/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.sekun.dev/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.sekun.dev/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.sekun.dev/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.sekun.dev/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="What I learned from building an emoji URL shortener in Rust">
<meta property="og:description" content="So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.
 Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.sekun.dev/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/">
<meta property="og:image" content="https://blog.sekun.dev/posts/p2-cover.png"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-04-11T06:20:00+00:00">
<meta property="article:modified_time" content="2021-04-11T06:20:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.sekun.dev/posts/p2-cover.png">
<meta name=twitter:title content="What I learned from building an emoji URL shortener in Rust">
<meta name=twitter:description content="So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.
 Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.sekun.dev/posts/"},{"@type":"ListItem","position":3,"name":"What I learned from building an emoji URL shortener in Rust","item":"https://blog.sekun.dev/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What I learned from building an emoji URL shortener in Rust","name":"What I learned from building an emoji URL shortener in Rust","description":"So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.\n Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:","keywords":["nix","postgresql","rust","axum"],"articleBody":"So, I made an emoji URL shortener with Rust and shared it in some places including the Rust community. And oh man this is the first thing I made that got this many visitors which is pretty nice knowing that people were curious enough to try it despite them probably feeling disgusted from me bringing such a thing to existence.\n Repo: https://github.com/sekunho/emojied Website: https://emojied.net  Some glowing ‚ú® reviews:\n ‚ÄúThanks, I hate it.‚Äù ‚Äì Pay08, 2022\n  ‚Äúdownvoted for being a menace to society.‚Äù ‚Äì MultiplyAccumulate, 2022\n  ‚Äúblursed \" ‚Äì Jaxius3\n  ‚Äú‚ÄúMade with regret.‚Äù Hahahaha. Excellent.‚Äù ‚Äì IronWhiskers, 2022\n  ‚ÄúWhat is wrong with you?‚Äù ‚Äì Jeff\n   That‚Äôs a lot of people disgusted by what I made\n  Here are some of the things I learned from building a simple project.\nTech Stack After looking around, I decided to go with the following:\n axum (web server) maud (HTML templates via Rust macros) postgres (persistent data storage and business logic) sqitch (database schema migration tool) typescript (you know what this is) docker (‚Äúsimple‚Äù deploys) nix (reproducible environments)  PostgreSQL Procedures Procedures are extremely cool although this isn‚Äôt exactly new to me. I‚Äôve been experimenting with this in one of my previous, unfinished projects called GNAWEX 1 (One day I will finish it don‚Äôt you worry).\nThis allows you to implement some business logic in SQL, without having to implement it in the application level. If ever PostgreSQL is a constant in your project, and intend to rewrite the app from scratch, you might just end up having to rewrite the glue rather than your business logic. emojied isn‚Äôt doing anything too exciting though, so I can‚Äôt really demonstrate all that is cool about it.\nOkay, an example would be fetching a URL given an identifier, and incrementing the clicks column by one. Here‚Äôs an example of a procedure that does exactly that:\nCREATE FUNCTION app.get_url(query TEXT) -- ^ This contains the emoji sequence `identifier`  RETURNS TEXT LANGUAGE sql AS $$ -- Considered as a \"clicked\" link whenever this gets triggered  UPDATE app.links SET clicks = clicks + 1 WHERE links.identifier = $1; -- Builds the URL so that I don't have to do this in the web server  SELECT concat(scheme, '://', hosts.name, path) AS url FROM app.links JOIN app.hosts ON links.host = hosts.host_id WHERE links.identifier = $1; $$; It‚Äôs a simple function that uses SQL as the language that expects any TEXT, and returns a TEXT as well, which is a sequence of emojis, and the URL it maps to respectively. Since whatever happens in this procedure is in the same transaction as what called it, e.g (SELECT * FROM app.get_url('üçäüåê')), if any of this fails, then it rolls back everything, including the incrementing of clicks. If this was at the application level, I‚Äôd have to reach for whatever transaction implementation it uses (like Ecto.Multi) which doesn‚Äôt make sense in this case cause Postgres already natively supports transactions.\nI try to make heavy use of stored procedures as long as it‚Äôs applicable. Inserting to multiple tables with one function, fetching leaderboard entries, etc.\nError handling with implicit From Error handling is pretty nice with Rust, especially since I was never a fan of exceptions since it made control flow so weird. Although that may be because I never really invested that much time working with them. In Rust, I like that you can do two things for errors: errors encoded as ADTs, or panic (unrecoverable). Although I‚Äôm not entirely sure if all errors can be encoded in sum types, and what can be done if ever one needs to recover from a panic. But for emojied, I definitely don‚Äôt have to think about that.\nWhat I did have to deal with was finding a more convenient way when dealing with other Error types. For instance, there‚Äôs tokio_postgres::Error, then there‚Äôs env::VarError, and if I need to bubble up these errors to the binary, I‚Äôm gonna need a convenient enough way to do that otherwise I‚Äôm gonna have a difficult time.\nLet‚Äôs say I have two errors, a database one, and an application one.\nenum AppError { Foo, Baz } enum DbError { FailedToConnect, InvalidTLSCert } fn some_db_action() - ResultString, DbError { Err(DbError::FailedToConnect) } fn some_app_action() - ResultString, AppError { let result1 = some_db_action()?; let result2 = some_db_action()?; Ok(result1) } This fails to compile, here‚Äôs what rustc says:\nerror[E0277]: `?` couldn't convert the error to `AppError` | 212 | fn app_action() - Result{ | ------------------------ expected `AppError` because of this 213 | let result1 = db_action()?; 214 | let result2 = db_action()?; | ^ the trait `From` is not implemented for `AppError` | = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `Fro m` trait = note: required because of the requirements on the impl of `FromResidual` for `Result` For more information about this error, try `rustc --explain E0277`. So it tells me that using ? implicitly converts DbError to AppError via the From trait. And because I do not have a trait instance like impl From for AppError, it fails.\nAnother thing is I somehow need to bubble up DbError up to the application error somehow. The method I ended up using is to just add a field to the AppError record. It‚Äôs a bit tiring to copy all the DbError variants over to the AppError enum. I mean, it‚Äôs fine for this one since it doesn‚Äôt have that many, but it becomes.\nenum AppError { DbError(DbError), // Hooray!  Foo, Baz } And then I can create a From instance:\nimpl FromDbError for AppError { fn from(e: DbError) - Self { AppError::DbError(e) } } Which compiles!\nIf I wanted to avoid From, I could do this:\nlet result1 = db_action().map_err(|_| AppError::Foo)?; Except it‚Äôs kinda annoying cause I have to do this at every call site. Although there are times when I did end up using this.\nApplication configuration While convenient, I can‚Äôt just hard-code everything into the application, especially for a public project. There are a lot of sensitive data like certs, and sometimes it‚Äôs just more convenient for whoever is using the application to change stuff without touching the source code. In my case, I had to make it flexible enough to change database credentials.\n A common way to do it is through environment variables.\ne.g PG__HOST=\"db.example.com\" emojied. So whenever I need to update stuff, all I have to do is just change the environment variable, and I‚Äôm spared from touching the source code!\n Here‚Äôs emojied‚Äôs config for it to run:\npub struct AppConfig { /// Application host  pub host: String, /// PostgreSQL config  pub pg: tokio_postgres::Config, /// Pool manager config  pub manager: ManagerConfig, /// Pool size  pub pool_size: usize, pub ca_cert_path: OptionString, } Then I created an associated function for it called from_env/0 which returns a Result. I‚Äôll talk about the Error part in the Error Handling section. Then I can use Rust‚Äôs std::env module to get a var‚Äôs value!\nHere‚Äôs a tiny example:\nuse std::env; struct AppConfig { pg_host: String, } impl AppConfig { fn from_env() - ResultAppConfig, Error { let host = env::var(\"PG__HOST\")?; Ok(AppConfig { pg_host: host }) } }  Side note: This kinda looks monadic, where it binds AppConfig to host, and evaluates to Error and ‚Äúexits‚Äù otherwise.\n Handling database‚Ä¶handler in axum I created this database handle that has all the things I need to communicate with the database server:\npub struct Handle { pub pool: Pool, } It‚Äôs pretty simple. It‚Äôs a struct that has a pool field. Then I created two more functions to make things more convenient: new/1, and client/1.\nnew(config: AppConfig) - Result expects an AppConfig as an argument, and if all goes well, then a new database handle with all the important things in it. client(\u0026self) - Result expects a reference to self, which is Handle in this case. This uses the DB pool to create a new client. From this client, you can do DB queries with it.\n// Grabs a client from the pool let client = handle.client().await?; // Runs a query that gets a URL's stats let data = client .query(\"SELECT * FROM app.get_url_stats($1)\", \u0026[\u0026identifier]) .await?; // Manually maps the row to a leaderboard entry let db_id = data[0].try_get(0)?; let db_clicks = data[0].try_get(1)?; let db_url = data[0].try_get(2)?; Ok(leaderboard::Entry { identifier: db_id, clicks: db_clicks, url: db_url, }) Okay, so I somehow need access to the database handle in the ‚Äúcontrollers‚Äù, like in controllers::leaderboard.\n I‚Äôm only calling it a controller since it‚Äôs a common concept. axum doesn‚Äôt call it that.\n let app = Router::new() .route(\"/leaderboard\", routing::get(controllers::leaderboard)); axum recommends 2 mentions that you could use ‚Äúrequest extensions‚Äù which looks like it acts like middleware. It recommends to have Arc inhabit Extension (Extension), but why?\nTime to do it in some wrong ways. This is fine since rustc is quite helpful with its error messages.\nI‚Äôll try to move handle instead:\nuse axum::{extract::Extension, routing::get, Router}; use std::net::SocketAddr; pub async fn run(handle: db::Handle) - Result(), hyper::Error { let app = Router::new() .route(\"/leaderboard\", routing::get(controllers::leaderboard)) .layer(Extension(handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await } Doing that gives me this error:\nerror[E0277]: the trait bound `db::Handle: Clone` is not satisfied -- src/lib.rs:36:16 | 36 | .layer(Extension(handle)); | ----- ^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `db::Handle` | | | required by a bound introduced by this call | = note: required because of the requirements on the impl of `tower_layer::Layer` for `Extension` For more information about this error, try `rustc --explain E0277`. It seems like I need to derive Clone for db::Handle since it probably gets cloned every time, although I‚Äôm not sure exactly when it does get cloned. In every new request?\nSo what happens if I do derive Clone?\n#[derive(Clone)] struct Handle { pub pool: Pool } Then I need to make sure that the function‚Äôs type signature matches:\npub async fn leaderboard( Extension(handle): Extensiondb::Handle // ^ Here! axum seems to know exactly where to apply it to the args. Not sure  // how this is done (yet). ) - (StatusCode, Markup) { match leaderboard::fetch(\u0026handle).await { Ok(entries) = { (StatusCode::OK, views::leaderboard::render(entries)) }, Err(_e) = (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}), } } Well, it seems to compile just fine. The leaderboard page works fine as well. I don‚Äôt really have that much experience with this yet but my current assumption is that I‚Äôm required to derive Clone for Handle since there‚Äôs no way to do shared ownership. So what it does is that it ends up cloning it every time. But, what if I don‚Äôt want to clone it? What if I just pass around references?\npub async fn run(handle: db::Handle) - Result(), hyper::Error { let app = Router::new() .route(\"/leaderboard\", routing::get(controllers::leaderboard)) .layer(Extension(\u0026handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await Compiles with this helpful error message:\nerror[E0597]: `handle` does not live long enough -- src/lib.rs:36:26 | 22 | let app = Router::new() | _______________- 23 | | .route(\"/leaderboard\", routing::get(controllers::leaderboard)) 24 | | .layer(Extension(\u0026handle)); | |__________________________^^^^^^^_- argument requires that `handle` is borrowed for `'static` | | | borrowed value does not live long enough ... 44 | } | - `handle` dropped here while still borrowed For more information about this error, try `rustc --explain E0597`. Unfortunately, I‚Äôm not too familiar with how lifetimes work in async/await. But it looks like since it‚Äôs non-blocking, handle gets dropped since the function reaches the end of its scope while the server is still running.\n This is all just somewhat smart guessing though. I‚Äôm gonna need to do more reading on this topic.\n Wait, what about app then? Won‚Äôt this get dropped as well? I wanted to confirm if this did get moved, or if it did some other trickery I had no idea about:\nlet app = Router::new() .route(\"/leaderboard\", routing::get(controllers::leaderboard)) .layer(Extension(handle)); let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); let foo = axum::Server::bind(\u0026addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await; println!(\"{:?}\", app); foo So if app does get moved, then rustc should complain about me accessing a variable with no ownership; which it does:\nerror[E0382]: borrow of moved value: `app` -- src/lib.rs:46:22 | 22 | let app = Router::new() | --- move occurs because `app` has type `Router`, which does not implement the `Copy` trait ... 42 | .serve(app.into_make_service()) | ------------------- `app` moved due to this method call ... 46 | println!(\"{:?}\", app); | ^^^ value borrowed here after move | note: this function takes ownership of the receiver `self`, which moves `app` Phew! It‚Äôs almost like I‚Äôm encouraged to try out all the failed scenarios to learn a lot of things since the compiler is quite helpful.\nOkay, since I didn‚Äôt want this to get cloned all the time, I will just follow what axum used in its examples - the usage of Arc:\npub async fn run(handle: db::Handle) - Result(), hyper::Error { let handle = Arc::new(handle); // ^ Shadow previous binding with `Arc`  let app = Router::new() .route(\"/leaderboard\", routing::get(controllers::leaderboard)) .layer(Extension(handle)); // ^ Here  let addr = SocketAddr::from(([0, 0, 0, 0], 3000)); axum::Server::bind(\u0026addr) .serve(app.into_make_service()) .with_graceful_shutdown(signal_shutdown()) .await } And then I‚Äôll remove the Clone derivation:\npub struct Handle { pub pool: Pool, } So if I‚Äôm not mistaken, which I probably am, Arc should allow me to share ownership of db::Handle without having to clone it 3.\npub async fn leaderboard( Extension(handle): ExtensionArcdb::Handle ) - (StatusCode, Markup) { match leaderboard::fetch(\u0026*handle).await { Ok(entries) = { (StatusCode::OK, views::leaderboard::render(entries)) }, Err(_e) = (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}), } } Then in leaderboard::fetch/1:\npub async fn fetch_url( handle: \u0026db::Handle, identifier: String ) - ResultString, Error { let client = handle.client().await?; let row = client .query_one(\"SELECT app.get_url($1)\", \u0026[\u0026identifier]) .await?; row.try_get(0).map_err(|e| Error::from(e)) } Although, I had to manually dereference it to get the reference to Handle. It‚Äôs also a good thing that I don‚Äôt have to mutate handle at all because otherwise this would‚Äôve been a more painful experience.\nConnecting to a managed database Initially, I used sqlx as the db library since it gets recommended in almost every post about SQL libraries on the Rust subreddit. It worked fine for me until I had to get it to connect to DO‚Äôs managed DB. It required me to connect to it via TLS, and it wasn‚Äôt a pleasant experience trying to debug what‚Äôs wrong with sqlx, so I ditched it settled with tokio-postgres, deadpool-postgres, and native-tls. Oh, I also had a difficult time 4 with rustls since it didn‚Äôt seem to like DO‚Äôs CA certificate, which is why I settled with native-tls.\nnative-tls needed OpenSSL setup, which I was able to do with Nix (for the dev environment):\n# ... devShell = pkgs.mkShell { # inherit (self.checks.${system}.pre-commit-check) shellHook; buildInputs = with pkgs; [ # Back-end pkgs.rustc pkgs.cargo pkgs.openssl pkgs.pkg-config ]; PKG_CONFIG_PATH = \"${pkgs.openssl.dev}/lib/pkgconfig\"; }; # ... So I had to provide the CA cert during runtime, not build-time since: 1) it‚Äôll be easier to distribute the static binary and Docker image, and 2) some CA certs are only given during runtime (like DO if ever you‚Äôre using app platform). This was my process:\n Build static binary \u0026 image without CA certs and other DB secrets When the image runs, it‚Äôs assumed that the necessary environment variables, like one that contains the certificate contents, exist. Write the certificate contents to a file. Run emojied  This seems to be a pretty standard process, although this is fairly tedious.\n// src/config.rs use tokio_postgres::config::SslMode; let mut pg_config = tokio_postgres::Config::new(); // I also read other PG values like hostname, DB name, user, etc. but excluded // those for brevity.  // Not providing CA_CERT is fine let ca_cert_path = match env::var(\"PG__CA_CERT\") { Ok(path) = { // I think `Prefer` is fine as well, which is the default  // for `tokio-postgres`.  pg_config.ssl_mode(SslMode::Require); Some(path) }, Err(_e) = { None } }; I allowed it to continue running without the cert path in PG__CA_CERT for dev environments.\n// Somewhere in src/db.rs  let manager = match app_config.ca_cert_path { Some(ca_cert_path) = { // Read file into byte vector  let cert = std::fs::read(ca_cert_path) .map_err(|e| Error::CACertFileError(e))?; // Create a certificate from a PEM file  let ntls_cert = Certificate::from_pem(\u0026cert) .map_err(|_| Error::InvalidCACert)?; let tls = TlsConnector::builder() .add_root_certificate(ntls_cert) .build() .map_err(|_| Error::FailedToBuildTlsConnector)?; let conn = MakeTlsConnector::new(tls); Manager::from_config(app_config.pg, conn, app_config.manager) } None = Manager::from_config(app_config.pg, NoTls, app_config.manager), }; // Since we need a `manager` to build a pool let pool = Pool::builder(manager) .max_size(app_config.pool_size) .build() .map_err(|_| Error::FailedToBuildPool)?;  The process was quite similar with SQLx but there was something, that I don‚Äôt really remember anymore, which made it so frustrating to work with.\n Unfortunately, DO doesn‚Äôt support multiline environment variables, for some reason, so cramming everything including the BEGIN CERTIFICATE and END CERTIFICATE into one line resulted in it getting rejected. So, I just got what‚Äôs in between, and manually appended it to the file instead.\necho \"Dumping CA certificate to /app/ca-certificate.crt\" echo \"-----BEGIN CERTIFICATE-----\"  /app/ca-certificate.crt echo $CA_CERT  /app/ca-certificate.crt echo \"-----END CERTIFICATE-----\"  /app/ca-certificate.crt echo \"Executing emojied\" ./emojied Kind of hacky, and inconvenient especially if I forget. But it works!\nURL redirect woes This is a short one. For the redirect, I returned an HTTP status 301 5 with a response containing the URL to redirect to. So the process goes something like this:\n Enter https://emojied.net/üçäüåê in the browser. emojied looks for an entry with üçäüåê, and gets the associated URL. Respond with an HTTP 301 and the URL Browser automatically performs the redirect  Unfortunately, and I spent 30mins on this scratching my head why this was happening, the request would get cached, and this is bad! It‚Äôs bad because I had to increment the clicks column every time the link is visited. But if it‚Äôs cached, then the server won‚Äôt bother to call the functions it needs to call!\nThen, I found out that 301 gets cached automatically by the browser 6, and that I needed to use 302.\nHTML templating with maud I had a pleasant experience with server-side templating while I was building a Haskell project called Swoogle. I used lucid 7 which was a pretty darn elegant HTML DSL.\n-- Category options select_ [ id_ \"category-options\" , name_ \"resource\" , class_ \"bg-white font-semibold dark:bg-su-dark-bg-alt text-su-fg dark:text-su-dark-fg\" , required_ \"required\" ] $ do option_ [disabled_ \"disabled\", selected_ \"selected\", value_ \"\"] \"Category\" option_ [value_ \"people\"] \"People\" option_ [value_ \"film\"] \"Film\" option_ [value_ \"starship\"] \"Starship\" option_ [value_ \"vehicle\"] \"Vehicle\" option_ [value_ \"species\"] \"Species\" option_ [value_ \"planet\"] \"Planet\" Well, I wanted something like that in Rust, and I found maud 8. It‚Äôs not as ‚Äúnice‚Äù, and it uses macros pretty heavily. But I don‚Äôt think I mind it too much. I did run into a problem when I tried to use its latest version with axum since a trait probably wasn‚Äôt implemented properly, so I had to pull from the main instead:\n[dependencies] ... maud = { git = \"https://github.com/lambda-fairy/maud\", branch = \"main\", features = [\"axum\"] } ... So with this, I could do stuff like:\nfn foo() - Markup { html! { h1 class=\"text-red-500\" { (\"Hello!\") } } } But it doesn‚Äôt compose as nicely as lucid:\nfn foo(content: Markup) - Markup { html! { h1 class=\"text-red-500\" { (\"Hello!\") } (content) } } fn bar() - Markup { let content = html! { h1 class=\"text-red-500\" { (\"Hello, from bar!\") } }; foo(content) } There‚Äôs a chance that I missed something. Although my copium is: it isn‚Äôt THAT bad.\n tag, and problems with JS toggling extensions I wanted to have the website work with JS disabled because, well, it was a very simple website. There was no reason why I couldn‚Äôt make all the important features work without JS!\nSo I ended up making heavy use of the  tag, since it allowed me to display alternative content when the browser has JS disabled. You‚Äôll see it littered all over the codebase, like so:\n@match data { RootData::Auto(_) = { noscript { div class=\"w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1\" { a href=\"?custom_url=t\" type=\"button\" class=\"font-medium underline\" { \"Custom URL\" } } } } RootData::Custom(_) = { noscript { div class=\"w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1\" { a href=\"/\" type=\"button\" class=\"font-medium underline\" { \"Autogenerate a custom URL for me\" } } } } } These only get rendered by the browser when JS is disabled. But what do browser extensions like NoScript when it ‚Äúdisables‚Äù JS? It‚Äôs something like this:\n Block requests for JS files via CSP (Content Security Policies) Replace noscript tags to span or div tags  The problem I ended up with was in #2. Why? Because the noscript tag attributes weren‚Äôt copied over to the new span/div tags. And that breaks a lot of stuff.\nSo while emojied does work without JS, it won‚Äôt work due to how the extensions work 9.\nConclusion Alright, that was a lot. I did learn a lot from this experience. I actually only read until chapter 10 of the Rust Book, and skipped to some parts like advanced traits, and other things. I really like the fact that there‚Äôs a detailed book that talks about some idiomatic Rust patterns, and even the more advanced stuff, that‚Äôs completely FREE. How crazy is that? My wallet is spared!\nI usually try to avoid failure, even in Haskell, cause its error messages are pretty bad. When I started out, it was pretty much worthless to read GHC‚Äôs error messages since it would just confuse me even more. It was only until I had people guide me (like justosophy, thank you) that I slowly got to understand what GHC was trying to tell me. With Rust though, it‚Äôs a completely different experience.\nI like failing because Rust is very helpful with its error messages. In fact, I discover new things by reading it so I‚Äôm not punished for trying out different things that don‚Äôt work just to gain more insight.\nI also like that it‚Äôs fairly easy on resources. I didn‚Äôt even bother optimizing this at all since I mostly have no idea what I‚Äôm doing, and I‚Äôm trying to avoid having to deal with lifetimes as much as possible. I‚Äôm hosting this on a 1x shared vCPU + 512MB RAM, and it didn‚Äôt break a sweat during peak load.\nAnyway, so far, so good! I‚Äôm pretty ecstatic to continue learning Rust.\n  https://github.com/gnawex/gnawex¬†‚Ü©Ô∏é\n https://docs.rs/axum/0.5.1/axum/#using-request-extensions¬†‚Ü©Ô∏é\n https://doc.rust-lang.org/std/sync/struct.Arc.html¬†‚Ü©Ô∏é\n https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/¬†‚Ü©Ô∏é\n https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301¬†‚Ü©Ô∏é\n https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations¬†‚Ü©Ô∏é\n https://hackage.haskell.org/package/lucid¬†‚Ü©Ô∏é\n https://github.com/lambda-fairy/maud¬†‚Ü©Ô∏é\n https://github.com/hackademix/noscript/issues/238¬†‚Ü©Ô∏é\n   ","wordCount":"3690","inLanguage":"en","image":"https://blog.sekun.dev/posts/p2-cover.png","datePublished":"2021-04-11T06:20:00Z","dateModified":"2021-04-11T06:20:00Z","author":{"@type":"Person","name":"sekun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.sekun.dev/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/"},"publisher":{"@type":"Organization","name":"sekun's blog","logo":{"@type":"ImageObject","url":"https://blog.sekun.dev/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.sekun.dev accesskey=h title="sekun's blog (Alt + H)">sekun's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.sekun.dev/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=https://blog.sekun.dev/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://blog.sekun.dev/archive/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
What I learned from building an emoji URL shortener in Rust
</h1>
<div class=post-meta><span title="2021-04-11 06:20:00 +0000 UTC">April 11, 2021</span>&nbsp;¬∑&nbsp;18 min&nbsp;¬∑&nbsp;sekun&nbsp;|&nbsp;<a href=https://github.com/sekunho/sekun.dev/tree/main/blog/content/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://blog.sekun.dev/posts/p2-cover.png alt="An image of a URL containing emojis">
<p>Nobody asked why I did this, and neither will I</p>
</figure><div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#tech-stack aria-label="Tech Stack">Tech Stack</a></li>
<li>
<a href=#postgresql-procedures aria-label="PostgreSQL Procedures">PostgreSQL Procedures</a></li>
<li>
<a href=#error-handling-with-implicit-fromt aria-label="Error handling with implicit From&amp;lt;T&amp;gt;">Error handling with implicit <code>From&lt;T></code></a></li>
<li>
<a href=#application-configuration aria-label="Application configuration">Application configuration</a></li>
<li>
<a href=#handling-databasehandler-in-axum aria-label="Handling database&amp;hellip;handler in axum">Handling database&mldr;handler in <code>axum</code></a></li>
<li>
<a href=#connecting-to-a-managed-database aria-label="Connecting to a managed database">Connecting to a managed database</a></li>
<li>
<a href=#url-redirect-woes aria-label="URL redirect woes">URL redirect woes</a></li>
<li>
<a href=#html-templating-with-maud aria-label="HTML templating with maud">HTML templating with <code>maud</code></a></li>
<li>
<a href=#noscript-tag-and-problems-with-js-toggling-extensions aria-label="&amp;lt;noscript&amp;gt; tag, and problems with JS toggling extensions"><code>&lt;noscript></code> tag, and problems with JS toggling extensions</a></li>
<li>
<a href=#conclusion aria-label=Conclusion>Conclusion</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>So, I made an emoji URL shortener with Rust and shared it in some places
including the <a href=https://old.reddit.com/r/rust/comments/tznryk/i_made_my_first_project_with_rust_its_a_url/>Rust community</a>.
And oh man this is the first thing I made that got this many visitors which is
pretty nice knowing that people were curious enough to try it <del>despite them probably
feeling disgusted from me bringing such a thing to existence</del>.</p>
<ul>
<li>Repo: <a href=https://github.com/sekunho/emojied>https://github.com/sekunho/emojied</a></li>
<li>Website: <a href=https://emojied.net>https://emojied.net</a></li>
</ul>
<p>Some glowing ‚ú® reviews:</p>
<blockquote>
<p>&ldquo;Thanks, I hate it.&rdquo; &ndash; Pay08, 2022</p>
</blockquote>
<blockquote>
<p>&ldquo;downvoted for being a menace to society.&rdquo; &ndash; MultiplyAccumulate, 2022</p>
</blockquote>
<blockquote>
<p>&ldquo;blursed " &ndash; Jaxius3</p>
</blockquote>
<blockquote>
<p>&ldquo;‚ÄúMade with regret.‚Äù Hahahaha. Excellent.&rdquo; &ndash; IronWhiskers, 2022</p>
</blockquote>
<blockquote>
<p>&ldquo;What is wrong with you?&rdquo; &ndash; Jeff</p>
</blockquote>
<figure>
<img loading=lazy src=/posts/p2-stats.png alt="That&amp;rsquo;s a lot of people disgusted by what I made"> <figcaption>
<p>That&rsquo;s a lot of people disgusted by what I made</p>
</figcaption>
</figure>
<p>Here are some of the things I learned from building a simple project.</p>
<h1 id=tech-stack>Tech Stack<a hidden class=anchor aria-hidden=true href=#tech-stack>#</a></h1>
<p>After looking around, I decided to go with the following:</p>
<ul>
<li><code>axum</code> (web server)</li>
<li><code>maud</code> (HTML templates via Rust macros)</li>
<li><code>postgres</code> (persistent data storage and business logic)</li>
<li><code>sqitch</code> (database schema migration tool)</li>
<li><code>typescript</code> (you know what this is)</li>
<li><code>docker</code> (&ldquo;simple&rdquo; deploys)</li>
<li><code>nix</code> (reproducible environments)</li>
</ul>
<h1 id=postgresql-procedures>PostgreSQL Procedures<a hidden class=anchor aria-hidden=true href=#postgresql-procedures>#</a></h1>
<p>Procedures are <em>extremely</em> cool although this isn&rsquo;t exactly new to me. I&rsquo;ve been
experimenting with this in one of my previous, unfinished projects called GNAWEX
<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> (One day I will finish it don&rsquo;t you worry).</p>
<p>This allows you to implement some business logic in SQL, without having to
implement it in the application level. If ever PostgreSQL is a constant in your
project, and intend to rewrite the app from scratch, you might just end up having
to rewrite the glue rather than your business logic. <code>emojied</code> isn&rsquo;t doing
anything too exciting though, so I can&rsquo;t really demonstrate all that is cool
about it.</p>
<p>Okay, an example would be fetching a URL given an identifier, and incrementing
the <code>clicks</code> column by one. Here&rsquo;s an example of a procedure that does exactly
that:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>FUNCTION</span> app.get_url(query TEXT)
                          <span style=color:#75715e>-- ^ This contains the emoji sequence `identifier`
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>RETURNS</span> TEXT
  <span style=color:#66d9ef>LANGUAGE</span> <span style=color:#66d9ef>sql</span>
  <span style=color:#66d9ef>AS</span> <span style=color:#960050;background-color:#1e0010>$$</span>
    <span style=color:#75715e>-- Considered as a &#34;clicked&#34; link whenever this gets triggered
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>UPDATE</span> app.links
      <span style=color:#66d9ef>SET</span> clicks <span style=color:#f92672>=</span> clicks <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>
      <span style=color:#66d9ef>WHERE</span> links.identifier <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>;

    <span style=color:#75715e>-- Builds the URL so that I don&#39;t have to do this in the web server
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>SELECT</span> concat(scheme, <span style=color:#e6db74>&#39;://&#39;</span>, hosts.name, path) <span style=color:#66d9ef>AS</span> url
      <span style=color:#66d9ef>FROM</span> app.links
      <span style=color:#66d9ef>JOIN</span> app.hosts
      <span style=color:#66d9ef>ON</span> links.<span style=color:#66d9ef>host</span> <span style=color:#f92672>=</span> hosts.host_id
      <span style=color:#66d9ef>WHERE</span> links.identifier <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>;
  <span style=color:#960050;background-color:#1e0010>$$</span>;
</code></pre></div><p>It&rsquo;s a simple function that uses SQL as the language that expects any <code>TEXT</code>,
and returns a <code>TEXT</code> as well, which is a sequence of emojis, and the URL it
maps to respectively. Since whatever happens in this procedure is in the same
transaction as what called it, e.g (<code>SELECT * FROM app.get_url('üçäüåê')</code>), if any
of this fails, then it rolls back everything, including the incrementing of
<code>clicks</code>. If this was at the application level, I&rsquo;d have to reach for whatever
transaction implementation it uses (like <code>Ecto.Multi</code>) which doesn&rsquo;t make sense
in this case cause Postgres already natively supports transactions.</p>
<p>I try to make heavy use of stored procedures as long as it&rsquo;s applicable.
Inserting to multiple tables with one function, fetching leaderboard entries,
etc.</p>
<h1 id=error-handling-with-implicit-fromt>Error handling with implicit <code>From&lt;T></code><a hidden class=anchor aria-hidden=true href=#error-handling-with-implicit-fromt>#</a></h1>
<p>Error handling is pretty nice with Rust, especially since I was never a fan of
exceptions since it made control flow so weird. Although that may be because I
never really invested that much time working with them. In Rust, I like that
you can do two things for errors: errors encoded as ADTs, or panic (unrecoverable).
Although I&rsquo;m not entirely sure if all errors can be encoded in sum types, and
what can be done if ever one needs to recover from a panic. But for <code>emojied</code>,
I definitely don&rsquo;t have to think about that.</p>
<p>What I did have to deal with was finding a more convenient way when dealing with
other <code>Error</code> types. For instance, there&rsquo;s <code>tokio_postgres::Error</code>, then there&rsquo;s
<code>env::VarError</code>, and if I need to bubble up these errors to the binary, I&rsquo;m gonna
need a convenient enough way to do that otherwise I&rsquo;m gonna have a difficult time.</p>
<p>Let&rsquo;s say I have two errors, a database one, and an application one.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>AppError</span> {
  Foo,
  Baz
}

<span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>DbError</span> {
    FailedToConnect,
    InvalidTLSCert
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>some_db_action</span>() -&gt; Result<span style=color:#f92672>&lt;</span>String, DbError<span style=color:#f92672>&gt;</span> {
    Err(DbError::FailedToConnect)
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>some_app_action</span>() -&gt; Result<span style=color:#f92672>&lt;</span>String, AppError<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> result1 <span style=color:#f92672>=</span> some_db_action()<span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> result2 <span style=color:#f92672>=</span> some_db_action()<span style=color:#f92672>?</span>;

    Ok(result1)
}
</code></pre></div><p>This fails to compile, here&rsquo;s what <code>rustc</code> says:</p>
<pre tabindex=0><code>error[E0277]: `?` couldn't convert the error to `AppError`
    |
212 | fn app_action() -&gt; Result&lt;String, AppError&gt; {
    |                    ------------------------ expected `AppError` because of this
213 |     let result1 = db_action()?;
214 |     let result2 = db_action()?;
    |                              ^ the trait `From&lt;url::DbError&gt;` is not implemented for `AppError`
    |
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `Fro
m` trait
    = note: required because of the requirements on the impl of `FromResidual&lt;Result&lt;Infallible, url::DbError&gt;&gt;`
 for `Result&lt;std::string::String, AppError&gt;`

For more information about this error, try `rustc --explain E0277`.
</code></pre><p>So it tells me that using <code>?</code> implicitly converts <code>DbError</code> to <code>AppError</code> via
the <code>From</code> trait. And because I do not have a trait instance like
<code>impl From&lt;DbError> for AppError</code>, it fails.</p>
<p>Another thing is I somehow need to bubble up <code>DbError</code> up to the application
error somehow. The method I ended up using is to just add a field to the
<code>AppError</code> record. It&rsquo;s a bit tiring to copy all the <code>DbError</code> variants over to
the <code>AppError</code> enum. I mean, it&rsquo;s fine for this one since it doesn&rsquo;t have that
many, but it becomes.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>AppError</span> {
    DbError(DbError), <span style=color:#75715e>// Hooray!
</span><span style=color:#75715e></span>    Foo,
    Baz
}
</code></pre></div><p>And then I can create a <code>From&lt;DbError></code> instance:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>impl</span> From<span style=color:#f92672>&lt;</span>DbError<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>for</span> AppError {
    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(e: <span style=color:#a6e22e>DbError</span>) -&gt; <span style=color:#a6e22e>Self</span> {
        AppError::DbError(e)
    }
}
</code></pre></div><p>Which compiles!</p>
<p>If I wanted to avoid <code>From</code>, I could do this:</p>
<pre tabindex=0><code>let result1 = db_action().map_err(|_| AppError::Foo)?;
</code></pre><p>Except it&rsquo;s kinda annoying cause I have to do this at every call site. Although
there are times when I did end up using this.</p>
<h1 id=application-configuration>Application configuration<a hidden class=anchor aria-hidden=true href=#application-configuration>#</a></h1>
<p>While convenient, I can&rsquo;t just hard-code everything into the application,
especially for a public project. There are a lot of sensitive data like certs,
and sometimes it&rsquo;s just <em>more</em> convenient for whoever is using the application
to change stuff without touching the source code. In my case, I had to make it
flexible enough to change database credentials.</p>
<blockquote>
<p>A common way to do it is through environment variables.</p>
<p>e.g <code>PG__HOST="db.example.com" emojied</code>. So whenever I need to update stuff, all
I have to do is just change the environment variable, and I&rsquo;m spared from
touching the source code!</p>
</blockquote>
<p>Here&rsquo;s <code>emojied</code>&rsquo;s config for it to run:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppConfig</span> {
    <span style=color:#e6db74>/// Application host
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> host: String,

    <span style=color:#e6db74>/// PostgreSQL config
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> pg: <span style=color:#a6e22e>tokio_postgres</span>::Config,

    <span style=color:#e6db74>/// Pool manager config
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> manager: <span style=color:#a6e22e>ManagerConfig</span>,

    <span style=color:#e6db74>/// Pool size
</span><span style=color:#e6db74></span>    <span style=color:#66d9ef>pub</span> pool_size: <span style=color:#66d9ef>usize</span>,

    <span style=color:#66d9ef>pub</span> ca_cert_path: Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
}
</code></pre></div><p>Then I created an associated function for it called <code>from_env/0</code> which returns
a <code>Result&lt;AppConfig, Error></code>. I&rsquo;ll talk about the <code>Error</code> part in the <code>Error Handling</code> section. Then I can use Rust&rsquo;s <code>std::env</code> module to get a var&rsquo;s value!</p>
<p>Here&rsquo;s a tiny example:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> std::env;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppConfig</span> {
  pg_host: String,
}

<span style=color:#66d9ef>impl</span> AppConfig {
  <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from_env</span>() -&gt; Result<span style=color:#f92672>&lt;</span>AppConfig, Error<span style=color:#f92672>&gt;</span> {
      <span style=color:#66d9ef>let</span> host <span style=color:#f92672>=</span> env::var(<span style=color:#e6db74>&#34;PG__HOST&#34;</span>)<span style=color:#f92672>?</span>;

      Ok(AppConfig { pg_host: <span style=color:#a6e22e>host</span> })
  }
}
</code></pre></div><blockquote>
<p>Side note: This kinda looks monadic, where it binds <code>AppConfig</code> to <code>host</code>, and
evaluates to <code>Error</code> and &ldquo;exits&rdquo; otherwise.</p>
</blockquote>
<h1 id=handling-databasehandler-in-axum>Handling database&mldr;handler in <code>axum</code><a hidden class=anchor aria-hidden=true href=#handling-databasehandler-in-axum>#</a></h1>
<p>I created this database handle that has all the things I need to communicate
with the database server:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Handle</span> {
    <span style=color:#66d9ef>pub</span> pool: <span style=color:#a6e22e>Pool</span>,
}
</code></pre></div><p>It&rsquo;s pretty simple. It&rsquo;s a struct that has a <code>pool</code> field. Then I created two
more functions to make things more convenient: <code>new/1</code>, and <code>client/1</code>.</p>
<p><code>new(config: AppConfig) -> Result&lt;Handle, Error></code> expects an <code>AppConfig</code> as an
argument, and if all goes well, then a new database handle with all the important
things in it. <code>client(&self) -> Result&lt;Pool, Error></code> expects a reference to
<code>self</code>, which is <code>Handle</code> in this case. This uses the DB pool to create a new
client. From this client, you can do DB queries with it.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// Grabs a client from the pool
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> client <span style=color:#f92672>=</span> handle.client().<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;

<span style=color:#75715e>// Runs a query that gets a URL&#39;s stats
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> data <span style=color:#f92672>=</span> client
    .query(<span style=color:#e6db74>&#34;SELECT * FROM app.get_url_stats($1)&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#f92672>&amp;</span>identifier])
    .<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;

<span style=color:#75715e>// Manually maps the row to a leaderboard entry
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> db_id <span style=color:#f92672>=</span> data[<span style=color:#ae81ff>0</span>].try_get(<span style=color:#ae81ff>0</span>)<span style=color:#f92672>?</span>;
<span style=color:#66d9ef>let</span> db_clicks <span style=color:#f92672>=</span> data[<span style=color:#ae81ff>0</span>].try_get(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>?</span>;
<span style=color:#66d9ef>let</span> db_url <span style=color:#f92672>=</span> data[<span style=color:#ae81ff>0</span>].try_get(<span style=color:#ae81ff>2</span>)<span style=color:#f92672>?</span>;

Ok(leaderboard::Entry {
    identifier: <span style=color:#a6e22e>db_id</span>,
    clicks: <span style=color:#a6e22e>db_clicks</span>,
    url: <span style=color:#a6e22e>db_url</span>,
})
</code></pre></div><p>Okay, so I somehow need access to the database handle in the &ldquo;controllers&rdquo;, like
in <code>controllers::leaderboard</code>.</p>
<blockquote>
<p>I&rsquo;m only calling it a controller since it&rsquo;s a common concept. <code>axum</code> doesn&rsquo;t
call it that.</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
    .route(<span style=color:#e6db74>&#34;/leaderboard&#34;</span>, routing::get(controllers::leaderboard));
</code></pre></div><p><code>axum</code> recommends <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> mentions that you could use &ldquo;request extensions&rdquo; which
looks like it acts like middleware. It recommends to have <code>Arc</code> inhabit
<code>Extension</code> (<code>Extension&lt;Arc&lt;T>></code>), but why?</p>
<p>Time to do it in some wrong ways. This is fine since <code>rustc</code> is quite helpful
with its error messages.</p>
<p>I&rsquo;ll try to move <code>handle</code> instead:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>use</span> axum::{extract::Extension, routing::get, Router};
<span style=color:#66d9ef>use</span> std::net::SocketAddr;

<span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(handle: <span style=color:#a6e22e>db</span>::Handle) -&gt; Result<span style=color:#f92672>&lt;</span>(), hyper::Error<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
        .route(<span style=color:#e6db74>&#34;/leaderboard&#34;</span>, routing::get(controllers::leaderboard))
        .layer(Extension(handle));
                      <span style=color:#75715e>// ^ Here
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> SocketAddr::from(([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>3000</span>));

    axum::Server::bind(<span style=color:#f92672>&amp;</span>addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(signal_shutdown())
        .<span style=color:#66d9ef>await</span>
}
</code></pre></div><p>Doing that gives me this error:</p>
<pre tabindex=0><code>error[E0277]: the trait bound `db::Handle: Clone` is not satisfied
  --&gt; src/lib.rs:36:16
   |
36 |         .layer(Extension(handle));
   |          ----- ^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `db::Handle`
   |          |
   |          required by a bound introduced by this call
   |
   = note: required because of the requirements on the impl of `tower_layer::Layer&lt;Route&lt;_&gt;&gt;` for `Extension&lt;db::
Handle&gt;`

For more information about this error, try `rustc --explain E0277`.
</code></pre><p>It seems like I need to derive <code>Clone</code> for <code>db::Handle</code> since it probably gets
cloned every time, although I&rsquo;m not sure exactly when it does get cloned. In
every new request?</p>
<p>So what happens if I <em>do</em> derive <code>Clone</code>?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>#[derive(Clone)]</span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Handle</span> {
  <span style=color:#66d9ef>pub</span> pool: <span style=color:#a6e22e>Pool</span>
}
</code></pre></div><p>Then I need to make sure that the function&rsquo;s type signature matches:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>leaderboard</span>(
    Extension(handle): <span style=color:#a6e22e>Extension</span><span style=color:#f92672>&lt;</span>db::Handle<span style=color:#f92672>&gt;</span>
 <span style=color:#75715e>// ^ Here! axum seems to know exactly where to apply it to the args. Not sure
</span><span style=color:#75715e></span> <span style=color:#75715e>// how this is done (yet).
</span><span style=color:#75715e></span>) -&gt; (StatusCode, Markup) {
    <span style=color:#66d9ef>match</span> leaderboard::fetch(<span style=color:#f92672>&amp;</span>handle).<span style=color:#66d9ef>await</span> {
        Ok(entries) <span style=color:#f92672>=&gt;</span> {
            (StatusCode::OK, views::leaderboard::render(entries))
        },
        Err(_e) <span style=color:#f92672>=&gt;</span> (StatusCode::INTERNAL_SERVER_ERROR, maud::html<span style=color:#f92672>!</span> {}),
    }
}
</code></pre></div><p>Well, it seems to compile just fine. The leaderboard page works fine as well.
I don&rsquo;t really have that much experience with this yet but my current assumption
is that I&rsquo;m required to derive <code>Clone</code> for <code>Handle</code> since there&rsquo;s no way to do
shared ownership. So what it does is that it ends up cloning it every time. But,
what if I don&rsquo;t want to clone it? What if I just pass around references?</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(handle: <span style=color:#a6e22e>db</span>::Handle) -&gt; Result<span style=color:#f92672>&lt;</span>(), hyper::Error<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
        .route(<span style=color:#e6db74>&#34;/leaderboard&#34;</span>, routing::get(controllers::leaderboard))
        .layer(Extension(<span style=color:#f92672>&amp;</span>handle));
                      <span style=color:#75715e>// ^ Here
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> SocketAddr::from(([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>3000</span>));

    axum::Server::bind(<span style=color:#f92672>&amp;</span>addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(signal_shutdown())
        .<span style=color:#66d9ef>await</span>
</code></pre></div><p>Compiles with this helpful error message:</p>
<pre tabindex=0><code>error[E0597]: `handle` does not live long enough
  --&gt; src/lib.rs:36:26
   |
22 |       let app = Router::new()
   |  _______________-
23 | |         .route(&quot;/leaderboard&quot;, routing::get(controllers::leaderboard))
24 | |         .layer(Extension(&amp;handle));
   | |__________________________^^^^^^^_- argument requires that `handle` is borrowed for `'static`
   |                            |
   |                            borrowed value does not live long enough
...
44 |   }
   |   - `handle` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
</code></pre><p>Unfortunately, I&rsquo;m not too familiar with how lifetimes work in <code>async</code>/<code>await</code>.
But it looks like since it&rsquo;s non-blocking, <code>handle</code> gets dropped since the function
reaches the end of its scope while the server is still running.</p>
<blockquote>
<p>This is all just somewhat smart guessing though. I&rsquo;m gonna need to do more
reading on this topic.</p>
</blockquote>
<p>Wait, what about <code>app</code> then? Won&rsquo;t this get dropped as well? I wanted to confirm
if this did get moved, or if it did some other trickery I had no idea about:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
        .route(<span style=color:#e6db74>&#34;/leaderboard&#34;</span>, routing::get(controllers::leaderboard))
        .layer(Extension(handle));

    <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> SocketAddr::from(([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>3000</span>));

    <span style=color:#66d9ef>let</span> foo <span style=color:#f92672>=</span>
        axum::Server::bind(<span style=color:#f92672>&amp;</span>addr)
            .serve(app.into_make_service())
            .with_graceful_shutdown(signal_shutdown())
            .<span style=color:#66d9ef>await</span>;

    println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, app);

    foo
</code></pre></div><p>So if <code>app</code> does get moved, then <code>rustc</code> should complain about me accessing a
variable with no ownership; which it does:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust>error[E0382]: <span style=color:#a6e22e>borrow</span> of moved value: <span style=color:#960050;background-color:#1e0010>`</span>app<span style=color:#960050;background-color:#1e0010>`</span>
   <span style=color:#f92672>-</span>-&gt; <span style=color:#a6e22e>src</span><span style=color:#f92672>/</span>lib.rs:<span style=color:#ae81ff>46</span>:<span style=color:#ae81ff>22</span>
    <span style=color:#f92672>|</span>
<span style=color:#ae81ff>22</span>  <span style=color:#f92672>|</span>     <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
    <span style=color:#f92672>|</span>         <span style=color:#f92672>---</span> <span style=color:#66d9ef>move</span> occurs because <span style=color:#960050;background-color:#1e0010>`</span>app<span style=color:#960050;background-color:#1e0010>`</span> has <span style=color:#66d9ef>type</span> <span style=color:#960050;background-color:#1e0010>`</span>Router<span style=color:#960050;background-color:#1e0010>`</span>, which does not implement the <span style=color:#960050;background-color:#1e0010>`</span>Copy<span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#66d9ef>trait</span>
<span style=color:#f92672>..</span>.
<span style=color:#ae81ff>42</span>  <span style=color:#f92672>|</span>             .serve(app.into_make_service())
    <span style=color:#f92672>|</span>                        <span style=color:#f92672>-------------------</span> <span style=color:#960050;background-color:#1e0010>`</span>app<span style=color:#960050;background-color:#1e0010>`</span> moved due to this method call
<span style=color:#f92672>..</span>.
<span style=color:#ae81ff>46</span>  <span style=color:#f92672>|</span>     println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, app);
    <span style=color:#f92672>|</span>                      <span style=color:#f92672>^^^</span> value borrowed here after <span style=color:#66d9ef>move</span>
    <span style=color:#f92672>|</span>
note: <span style=color:#a6e22e>this</span> function takes ownership of the receiver <span style=color:#960050;background-color:#1e0010>`</span>self<span style=color:#960050;background-color:#1e0010>`</span>, which moves <span style=color:#960050;background-color:#1e0010>`</span>app<span style=color:#960050;background-color:#1e0010>`</span>
</code></pre></div><p>Phew! It&rsquo;s almost like I&rsquo;m encouraged to try out all the failed scenarios to
learn a lot of things since the compiler is quite helpful.</p>
<p>Okay, since I didn&rsquo;t want this to get cloned all the time, I will just follow
what <code>axum</code> used in its examples - the usage of <code>Arc&lt;T></code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(handle: <span style=color:#a6e22e>db</span>::Handle) -&gt; Result<span style=color:#f92672>&lt;</span>(), hyper::Error<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> handle <span style=color:#f92672>=</span> Arc::new(handle);
    <span style=color:#75715e>//  ^ Shadow previous binding with `Arc&lt;db::Handle&gt;`
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> app <span style=color:#f92672>=</span> Router::new()
        .route(<span style=color:#e6db74>&#34;/leaderboard&#34;</span>, routing::get(controllers::leaderboard))
        .layer(Extension(handle));
                      <span style=color:#75715e>// ^ Here
</span><span style=color:#75715e></span>
    <span style=color:#66d9ef>let</span> addr <span style=color:#f92672>=</span> SocketAddr::from(([<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>], <span style=color:#ae81ff>3000</span>));

    axum::Server::bind(<span style=color:#f92672>&amp;</span>addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(signal_shutdown())
        .<span style=color:#66d9ef>await</span>
}
</code></pre></div><p>And then I&rsquo;ll remove the <code>Clone</code> derivation:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Handle</span> {
    <span style=color:#66d9ef>pub</span> pool: <span style=color:#a6e22e>Pool</span>,
}
</code></pre></div><p>So if I&rsquo;m not mistaken, which I probably am, <code>Arc&lt;T></code> should allow me to share
ownership of <code>db::Handle</code> without having to clone it <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>leaderboard</span>(
    Extension(handle): <span style=color:#a6e22e>Extension</span><span style=color:#f92672>&lt;</span>Arc<span style=color:#f92672>&lt;</span>db::Handle<span style=color:#f92672>&gt;&gt;</span>
) -&gt; (StatusCode, Markup) {
    <span style=color:#66d9ef>match</span> leaderboard::fetch(<span style=color:#f92672>&amp;*</span>handle).<span style=color:#66d9ef>await</span> {
        Ok(entries) <span style=color:#f92672>=&gt;</span> {
            (StatusCode::OK, views::leaderboard::render(entries))
        },
        Err(_e) <span style=color:#f92672>=&gt;</span> (StatusCode::INTERNAL_SERVER_ERROR, maud::html<span style=color:#f92672>!</span> {}),
    }
}
</code></pre></div><p>Then in <code>leaderboard::fetch/1</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fetch_url</span>(
    handle: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>db</span>::Handle,
    identifier: String
) -&gt; Result<span style=color:#f92672>&lt;</span>String, Error<span style=color:#f92672>&gt;</span> {
    <span style=color:#66d9ef>let</span> client <span style=color:#f92672>=</span> handle.client().<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;
    <span style=color:#66d9ef>let</span> row <span style=color:#f92672>=</span> client
        .query_one(<span style=color:#e6db74>&#34;SELECT app.get_url($1)&#34;</span>, <span style=color:#f92672>&amp;</span>[<span style=color:#f92672>&amp;</span>identifier])
        .<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;

    row.try_get(<span style=color:#ae81ff>0</span>).map_err(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> Error::from(e))
}
</code></pre></div><p>Although, I had to manually dereference it to get the reference to <code>Handle</code>. It&rsquo;s
also a good thing that I don&rsquo;t have to mutate <code>handle</code> at all because otherwise
this would&rsquo;ve been a more painful experience.</p>
<h1 id=connecting-to-a-managed-database>Connecting to a managed database<a hidden class=anchor aria-hidden=true href=#connecting-to-a-managed-database>#</a></h1>
<p>Initially, I used <code>sqlx</code> as the db library since it gets recommended in almost
every post about SQL libraries on the Rust subreddit. It worked fine for me
until I had to get it to connect to DO&rsquo;s managed DB. It required me to connect
to it via TLS, and it wasn&rsquo;t a pleasant experience trying to debug what&rsquo;s wrong
with <code>sqlx</code>, so I ditched it settled with <code>tokio-postgres</code>, <code>deadpool-postgres</code>,
and <code>native-tls</code>. Oh, I also had a difficult time <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> with <code>rustls</code> since it
didn&rsquo;t seem to like DO&rsquo;s CA certificate, which is why I settled with <code>native-tls</code>.</p>
<p><code>native-tls</code> needed OpenSSL setup, which I was able to do with Nix (for the
dev environment):</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>  <span style=color:#75715e># ...</span>
        devShell <span style=color:#960050;background-color:#1e0010>=</span> pkgs<span style=color:#f92672>.</span>mkShell {
          <span style=color:#75715e># inherit (self.checks.${system}.pre-commit-check) shellHook;</span>

          buildInputs <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> pkgs; [
            <span style=color:#75715e># Back-end</span>
            pkgs<span style=color:#f92672>.</span>rustc
            pkgs<span style=color:#f92672>.</span>cargo

            pkgs<span style=color:#f92672>.</span>openssl
            pkgs<span style=color:#f92672>.</span>pkg-config
          ];

          PKG_CONFIG_PATH <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>pkgs<span style=color:#f92672>.</span>openssl<span style=color:#f92672>.</span>dev<span style=color:#e6db74>}</span><span style=color:#e6db74>/lib/pkgconfig&#34;</span>;
        };

  <span style=color:#75715e># ...</span>
</code></pre></div><p>So I had to provide the CA cert during runtime, not build-time since: 1) it&rsquo;ll
be easier to distribute the static binary and Docker image, and 2) some CA certs
are only given during runtime (like DO if ever you&rsquo;re using app platform). This
was my process:</p>
<ol>
<li>Build static binary & image without CA certs and other DB secrets</li>
<li>When the image runs, it&rsquo;s assumed that the necessary environment variables,
like one that contains the certificate contents, exist.</li>
<li>Write the certificate contents to a file.</li>
<li>Run <code>emojied</code></li>
</ol>
<p>This seems to be a pretty standard process, although this is fairly tedious.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// src/config.rs
</span><span style=color:#75715e></span><span style=color:#66d9ef>use</span> tokio_postgres::config::SslMode;

<span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> pg_config <span style=color:#f92672>=</span> tokio_postgres::Config::new();

<span style=color:#75715e>// I also read other PG values like hostname, DB name, user, etc. but excluded
</span><span style=color:#75715e>// those for brevity.
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Not providing CA_CERT is fine
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> ca_cert_path <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> env::var(<span style=color:#e6db74>&#34;PG__CA_CERT&#34;</span>) {
    Ok(path) <span style=color:#f92672>=&gt;</span> {
        <span style=color:#75715e>// I think `Prefer` is fine as well, which is the default
</span><span style=color:#75715e></span>        <span style=color:#75715e>// for `tokio-postgres`.
</span><span style=color:#75715e></span>        pg_config.ssl_mode(SslMode::Require);
        Some(path)
    },
    Err(_e) <span style=color:#f92672>=&gt;</span> {
        None
    }
};
</code></pre></div><p>I allowed it to continue running without the cert path in <code>PG__CA_CERT</code> for
dev environments.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#75715e>// Somewhere in src/db.rs
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>let</span> manager <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> app_config.ca_cert_path {
    Some(ca_cert_path) <span style=color:#f92672>=&gt;</span> {
        <span style=color:#75715e>// Read file into byte vector
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> cert <span style=color:#f92672>=</span> std::fs::read(ca_cert_path)
            .map_err(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> Error::CACertFileError(e))<span style=color:#f92672>?</span>;

        <span style=color:#75715e>// Create a certificate from a PEM file
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> ntls_cert <span style=color:#f92672>=</span> Certificate::from_pem(<span style=color:#f92672>&amp;</span>cert)
            .map_err(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Error::InvalidCACert)<span style=color:#f92672>?</span>;

        <span style=color:#66d9ef>let</span> tls <span style=color:#f92672>=</span> TlsConnector::builder()
            .add_root_certificate(ntls_cert)
            .build()
            .map_err(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Error::FailedToBuildTlsConnector)<span style=color:#f92672>?</span>;

        <span style=color:#66d9ef>let</span> conn <span style=color:#f92672>=</span> MakeTlsConnector::new(tls);

        Manager::from_config(app_config.pg, conn, app_config.manager)
    }
    None <span style=color:#f92672>=&gt;</span> Manager::from_config(app_config.pg, NoTls, app_config.manager),
};

<span style=color:#75715e>// Since we need a `manager` to build a pool
</span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> pool <span style=color:#f92672>=</span> Pool::builder(manager)
    .max_size(app_config.pool_size)
    .build()
    .map_err(<span style=color:#f92672>|</span>_<span style=color:#f92672>|</span> Error::FailedToBuildPool)<span style=color:#f92672>?</span>;
</code></pre></div><blockquote>
<p>The process was quite similar with SQLx but there was something, that I don&rsquo;t
really remember anymore, which made it so frustrating to work with.</p>
</blockquote>
<p>Unfortunately, DO doesn&rsquo;t support multiline environment variables, for some
reason, so cramming everything including the <code>BEGIN CERTIFICATE</code> and <code>END CERTIFICATE</code>
into one line resulted in it getting rejected. So, I just got what&rsquo;s in between,
and manually appended it to the file instead.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>echo <span style=color:#e6db74>&#34;Dumping CA certificate to /app/ca-certificate.crt&#34;</span>
echo <span style=color:#e6db74>&#34;-----BEGIN CERTIFICATE-----&#34;</span> &gt; /app/ca-certificate.crt
echo $CA_CERT &gt;&gt; /app/ca-certificate.crt
echo <span style=color:#e6db74>&#34;-----END CERTIFICATE-----&#34;</span> &gt;&gt; /app/ca-certificate.crt

echo <span style=color:#e6db74>&#34;Executing emojied&#34;</span>

./emojied
</code></pre></div><p>Kind of hacky, and inconvenient especially if I forget. But it works!</p>
<h1 id=url-redirect-woes>URL redirect woes<a hidden class=anchor aria-hidden=true href=#url-redirect-woes>#</a></h1>
<p>This is a short one. For the redirect, I returned an HTTP status 301 <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> with
a response containing the URL to redirect to. So the process goes something
like this:</p>
<ol>
<li>Enter <a href=https://emojied.net/%F0%9F%8D%8A%F0%9F%8C%90>https://emojied.net/üçäüåê</a> in the browser.</li>
<li><code>emojied</code> looks for an entry with <code>üçäüåê</code>, and gets the associated URL.</li>
<li>Respond with an HTTP 301 and the URL</li>
<li>Browser automatically performs the redirect</li>
</ol>
<p>Unfortunately, and I spent 30mins on this scratching my head why this was
happening, the request would get cached, and this is bad! It&rsquo;s bad because I
had to increment the <code>clicks</code> column every time the link is visited. But if it&rsquo;s
cached, then the server won&rsquo;t bother to call the functions it needs to call!</p>
<p>Then, I found out that <code>301</code> gets cached automatically by the browser <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>,
and that I needed to use <code>302</code>.</p>
<h1 id=html-templating-with-maud>HTML templating with <code>maud</code><a hidden class=anchor aria-hidden=true href=#html-templating-with-maud>#</a></h1>
<p>I had a pleasant experience with server-side templating while I was building
a Haskell project called <a href=https://swoogle.sekun.dev>Swoogle</a>. I used <code>lucid</code>
<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> which was a pretty darn elegant HTML DSL.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#75715e>-- Category options</span>
<span style=color:#a6e22e>select_</span>
  [ id_ <span style=color:#e6db74>&#34;category-options&#34;</span>
  , name_ <span style=color:#e6db74>&#34;resource&#34;</span>
  , class_ <span style=color:#e6db74>&#34;bg-white font-semibold dark:bg-su-dark-bg-alt text-su-fg dark:text-su-dark-fg&#34;</span>
  , required_ <span style=color:#e6db74>&#34;required&#34;</span>
  ] <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
  option_ [disabled_ <span style=color:#e6db74>&#34;disabled&#34;</span>, selected_ <span style=color:#e6db74>&#34;selected&#34;</span>, value_ <span style=color:#e6db74>&#34;&#34;</span>] <span style=color:#e6db74>&#34;Category&#34;</span>
  option_ [value_ <span style=color:#e6db74>&#34;people&#34;</span>] <span style=color:#e6db74>&#34;People&#34;</span>
  option_ [value_ <span style=color:#e6db74>&#34;film&#34;</span>] <span style=color:#e6db74>&#34;Film&#34;</span>
  option_ [value_ <span style=color:#e6db74>&#34;starship&#34;</span>] <span style=color:#e6db74>&#34;Starship&#34;</span>
  option_ [value_ <span style=color:#e6db74>&#34;vehicle&#34;</span>] <span style=color:#e6db74>&#34;Vehicle&#34;</span>
  option_ [value_ <span style=color:#e6db74>&#34;species&#34;</span>] <span style=color:#e6db74>&#34;Species&#34;</span>
  option_ [value_ <span style=color:#e6db74>&#34;planet&#34;</span>] <span style=color:#e6db74>&#34;Planet&#34;</span>
</code></pre></div><p>Well, I wanted something like that in Rust, and I found <code>maud</code> <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>. It&rsquo;s not
as &ldquo;nice&rdquo;, and it uses macros pretty heavily. But I don&rsquo;t think I mind it too
much. I did run into a problem when I tried to use its latest version with
<code>axum</code> since a trait probably wasn&rsquo;t implemented properly, so I had to pull
from the <code>main</code> instead:</p>
<pre tabindex=0><code>[dependencies]
...
maud = { git = &quot;https://github.com/lambda-fairy/maud&quot;, branch = &quot;main&quot;, features = [&quot;axum&quot;] }
...
</code></pre><p>So with this, I could do stuff like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>() -&gt; <span style=color:#a6e22e>Markup</span> {
  html<span style=color:#f92672>!</span> {
    h1 class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text-red-500&#34;</span> { (<span style=color:#e6db74>&#34;Hello!&#34;</span>) }
  }
}
</code></pre></div><p>But it doesn&rsquo;t compose as nicely as <code>lucid</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>foo</span>(content: <span style=color:#a6e22e>Markup</span>) -&gt; <span style=color:#a6e22e>Markup</span> {
  html<span style=color:#f92672>!</span> {
    h1 class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text-red-500&#34;</span> { (<span style=color:#e6db74>&#34;Hello!&#34;</span>) }

    (content)
  }
}

<span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bar</span>() -&gt; <span style=color:#a6e22e>Markup</span> {
  <span style=color:#66d9ef>let</span> content <span style=color:#f92672>=</span>
      html<span style=color:#f92672>!</span> {
        h1 class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text-red-500&#34;</span> { (<span style=color:#e6db74>&#34;Hello, from bar!&#34;</span>) }
      };

  foo(content)
}
</code></pre></div><p>There&rsquo;s a chance that I missed something. Although my copium is: <em>it isn&rsquo;t THAT
bad</em>.</p>
<h1 id=noscript-tag-and-problems-with-js-toggling-extensions><code>&lt;noscript></code> tag, and problems with JS toggling extensions<a hidden class=anchor aria-hidden=true href=#noscript-tag-and-problems-with-js-toggling-extensions>#</a></h1>
<p>I wanted to have the website work with JS disabled because, well, it was a very
simple website. There was no reason why I couldn&rsquo;t make all the important features
work without JS!</p>
<p>So I ended up making heavy use of the <code>&lt;noscript></code> tag, since it allowed me to
display alternative content when the browser has JS disabled. You&rsquo;ll see it
littered all over the codebase, like so:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=color:#f92672>@</span><span style=color:#66d9ef>match</span> data {
    RootData::Auto(_) <span style=color:#f92672>=&gt;</span> {
        noscript {
            div class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1&#34;</span> {
                a href<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;?custom_url=t&#34;</span> <span style=color:#66d9ef>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;button&#34;</span> class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;font-medium underline&#34;</span> {
                    <span style=color:#e6db74>&#34;Custom URL&#34;</span>
                }
            }
        }
    }

    RootData::Custom(_) <span style=color:#f92672>=&gt;</span> {
        noscript {
            div class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1&#34;</span> {
                a href<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#66d9ef>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;button&#34;</span> class<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;font-medium underline&#34;</span> {
                    <span style=color:#e6db74>&#34;Autogenerate a custom URL for me&#34;</span>
                }
            }
        }
    }
}
</code></pre></div><p>These only get rendered by the browser when JS is disabled. But what do browser
extensions like <code>NoScript</code> when it &ldquo;disables&rdquo; JS? It&rsquo;s something like this:</p>
<ol>
<li>Block requests for JS files via CSP (Content Security Policies)</li>
<li>Replace <code>noscript</code> tags to <code>span</code> or <code>div</code> tags</li>
</ol>
<p>The problem I ended up with was in #2. Why? Because the <code>noscript</code> tag attributes
weren&rsquo;t copied over to the new <code>span</code>/<code>div</code> tags. And that breaks a lot of stuff.</p>
<p>So while <code>emojied</code> does work without JS, it won&rsquo;t work due to how the extensions
work <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>.</p>
<h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1>
<p>Alright, that was a lot. I did learn a lot from this experience. I actually only
read until chapter 10 of the Rust Book, and skipped to some parts like advanced
traits, and other things. I really like the fact that there&rsquo;s a detailed book
that talks about some idiomatic Rust patterns, and even the more advanced stuff,
that&rsquo;s completely <strong>FREE</strong>. How crazy is that? My wallet is spared!</p>
<p>I usually try to avoid failure, even in Haskell, cause its error messages are
pretty bad. When I started out, it was pretty much worthless to read GHC&rsquo;s error
messages since it would just confuse me even more. It was only until I had people
guide me (like justosophy, thank you) that I slowly got to understand what GHC
was trying to tell me. With Rust though, it&rsquo;s a completely different experience.</p>
<p>I like <em>failing</em> because Rust is very helpful with its error messages. In fact,
I discover new things by reading it so I&rsquo;m not punished for trying out different
things that don&rsquo;t work just to gain more insight.</p>
<p>I also like that it&rsquo;s fairly easy on resources. I didn&rsquo;t even bother optimizing
this at all since I mostly have no idea what I&rsquo;m doing, and I&rsquo;m trying to avoid
having to deal with lifetimes as much as possible. I&rsquo;m hosting this on a 1x shared
vCPU + 512MB RAM, and it didn&rsquo;t break a sweat during peak load.</p>
<p>Anyway, so far, so good! I&rsquo;m pretty ecstatic to continue learning Rust.</p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=https://github.com/gnawex/gnawex>https://github.com/gnawex/gnawex</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p><a href=https://docs.rs/axum/0.5.1/axum/#using-request-extensions>https://docs.rs/axum/0.5.1/axum/#using-request-extensions</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p><a href=https://doc.rust-lang.org/std/sync/struct.Arc.html>https://doc.rust-lang.org/std/sync/struct.Arc.html</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p><a href=https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/>https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301>https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p><a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations>https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:7 role=doc-endnote>
<p><a href=https://hackage.haskell.org/package/lucid>https://hackage.haskell.org/package/lucid</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:8 role=doc-endnote>
<p><a href=https://github.com/lambda-fairy/maud>https://github.com/lambda-fairy/maud</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:9 role=doc-endnote>
<p><a href=https://github.com/hackademix/noscript/issues/238>https://github.com/hackademix/noscript/issues/238</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.sekun.dev/tags/nix/>nix</a></li>
<li><a href=https://blog.sekun.dev/tags/postgresql/>postgresql</a></li>
<li><a href=https://blog.sekun.dev/tags/rust/>rust</a></li>
<li><a href=https://blog.sekun.dev/tags/axum/>axum</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.sekun.dev>sekun's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>