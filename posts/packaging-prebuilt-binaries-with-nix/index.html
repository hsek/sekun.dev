<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Packaging Pre-built Binaries with Nix Flake | sekun's blog</title>
<meta name=keywords content="nix,postgrest">
<meta name=description content="Here&rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn&rsquo;t have the version you want. Fortunately, there&rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?">
<meta name=author content="sekun">
<link rel=canonical href=https://blog.sekun.dev/posts/packaging-prebuilt-binaries-with-nix/>
<link rel=preconnect href=https://fonts.googleapis.com>
<link rel=preconnect href=https://fonts.gstatic.com crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Vollkorn:wght@400;500;600;700&display=swap" rel=stylesheet>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.c5fdf02d9fbdbf20a5d2f0688981e299eed4e35afd7c8b5989b9d6c8f9944a14.css integrity="sha256-xf3wLZ+9vyCl0vBoiYHime7U41r9fItZibnWyPmUShQ=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.sekun.dev/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.sekun.dev/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.sekun.dev/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.sekun.dev/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.sekun.dev/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><meta property="og:title" content="Packaging Pre-built Binaries with Nix Flake">
<meta property="og:description" content="Here&rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn&rsquo;t have the version you want. Fortunately, there&rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.sekun.dev/posts/packaging-prebuilt-binaries-with-nix/">
<meta property="og:image" content="https://blog.sekun.dev/posts/p1-cover.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-03-06T04:11:00+00:00">
<meta property="article:modified_time" content="2021-03-06T04:11:00+00:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://blog.sekun.dev/posts/p1-cover.jpg">
<meta name=twitter:title content="Packaging Pre-built Binaries with Nix Flake">
<meta name=twitter:description content="Here&rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn&rsquo;t have the version you want. Fortunately, there&rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.sekun.dev/posts/"},{"@type":"ListItem","position":3,"name":"Packaging Pre-built Binaries with Nix Flake","item":"https://blog.sekun.dev/posts/packaging-prebuilt-binaries-with-nix/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Packaging Pre-built Binaries with Nix Flake","name":"Packaging Pre-built Binaries with Nix Flake","description":"Here\u0026rsquo;s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn\u0026rsquo;t have the version you want. Fortunately, there\u0026rsquo;s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?","keywords":["nix","postgrest"],"articleBody":"Here’s the scenario: You have a nix environment all set up with all the dependencies you need for working on your next awesome project. All but one. nixpkgs doesn’t have the version you want. Fortunately, there’s a static binary file on their GitHub page. So should you just manually download it every time you set your project up, or should you write a Nix package that builds it from source?\nNone of em! I don’t want to maintain any bash scripts to do that. I just want to load up the Nix environment, and start.\nThat was pretty much what I ran into today, I wanted to have postgrest in my Nix environment so I hopped on nixpkgs search, only to find that the existing versions are quite old, as well as having to build the project from source. Which I didn’t want to do due to my limited LTE bandwidth. Why should I? postgrest has pre-built, static binaries in its GitHub releases page. Is there any way I can make use of that instead? And that’s what I set off to do today.\ntl;dr: Binaries are built, me copy. Me save mobile data. Happy.\n Disclaimer: I’m a Nix newbie.\n Setup I need to import the postgrest flake to an existing flake of another project. The project’s directory has a nix folder for all the packages that don’t exist in nixpkgs, like so:\nnix └── postgrest ├── flake.lock └── flake.nix The flake.lock gets automatically generated by Nix when it finds out that it doesn’t exist yet when running nix build; no need to create that. Here’s the starting flake.nix:\n{ description = \"REST API for any Postgres database\"; inputs = { nixpkgs.url = \"github:NixOS/nixpkgs\"; }; outputs = {self, nixpkgs}: { }; } A basic flake file has a set of inputs and outputs. The output here will be the postgrest package.\nTime to throw the binary in Nix.\nI have no idea how to build things in flakes, so consulting the wiki is pretty much a requirement 1! It covers things like how to enable flakes, and I won’t bother covering because I’ll only make a worse version of it.\nIt tells me about both the inputs and outputs schema. But because I only need nixpkgs for this one, there’s not much else for me to add to the inputs.\nHere’s the output schema:\n{ self, ... }@inputs: { # Executed by `nix flake check` checks.\"\".\"\" = derivation; # Executed by `nix build .#` packages.\"\".\"\" = derivation; # Executed by `nix build .` defaultPackage.\"\" = derivation; # Executed by `nix run .#` apps.\"\".\"\" = { type = \"app\"; program = \"\"; }; # Executed by `nix run . -- ` defaultApp.\"\" = { type = \"app\"; program = \"...\"; }; # Used for nixpkgs packages, also accessible via `nix build .#` legacyPackages.\"\".\"\" = derivation; # Default overlay, consumed by other flakes overlay = final: prev: { }; # Same idea as overlay but a list or attrset of them. overlays = {}; # Default module, consumed by other flakes nixosModule = { config }: { options = {}; config = {}; }; # Same idea as nixosModule but a list or attrset of them. nixosModules = {}; # Used with `nixos-rebuild --flake .#` # nixosConfigurations.\"\".config.system.build.toplevel must be a derivation nixosConfigurations.\"\" = {}; # Used by `nix develop` devShell.\"\" = derivation; # Used by `nix develop .#` devShells.\"\".\"\" = derivation; # Hydra build jobs hydraJobs.\"\".\"\" = derivation; # Used by `nix flake init -t ` defaultTemplate = { path = \"\"; description = \"template description goes here?\"; }; # Used by `nix flake init -t #` templates.\"\" = { path = \"\"; description = \"\"; }; } That’s a lot.\noutputs is a lambda with a set as its argument. Since nix functions can only have one argument, putting the stuff you need in a set is how you get around that restriction. {self, ...} is some form of pattern matching the fields in a set, and @inputs binds the set to input. Cool. The latter isn’t that useful to me in this scenario though, so I’ll omit that. It seems that in every flake outputs, self must be there. I don’t understand what self is, but I’ll leave that for another time.\nWith the schema, there are two fields that seem important: packages, and defaultPackage. packages would be useful if I wanted to have multiple versions of postgrest available for me to use like postgres-8-0-0 and postgrest-9-0-0, but I don’t! I only need the latest version, which is 9.0.0 at the time of writing. So we can ignore that, and I’ll use defaultPackage instead.\nHere’s what we have so far:\n{ description = \"REST API for any Postgres database\"; inputs = { nixpkgs.url = \"github:NixOS/nixpkgs\"; }; outputs = {self, nixpkgs}: { defaultPackage.x86_64-linux = with import nixpkgs { system = \"x86_64-linux\"; }; stdenv.mkDerivation rec { name = \"postgrest-${version}\"; version = \"9.0.0\"; # I still lack stuff here! }; }; } with import nixpkgs {system = \"x86_64-linux\"}; spares me from having to qualify everything like nixpkgs.system.\"x86_64\".stdenv.mkDerivation which is handy 2. This brings stdenv into scope, and has mkDerivation which, from the name, makes a derivation; something I need for defaultPackage.. Unfortunately, I couldn’t find any official documentation for mkDerivation that species every single field usable in it. Maybe it exists and that I just suck at Googling. That is definitely possible. There are some examples 3, especially in the wild.\nrec allows me to refer to the set’s own fields within it. I’m using the field version and interpolated it in name!\nAlright that’s it for the setup. Time to fetch the binary.\nFetching the binary The wiki has an example for fetching stuff from a URL, and using it in mkDerivation 4.\nsrc = fetchurl { url = \"https://download.studio.link/releases/v${version}-stable/linux/studio-link-standalone-v${version}.tar.gz\"; sha256 = \"sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=\"; }; So it looks like I need two things, a url which can be a tar file, and a sha256. The sha256 field is used to make something impure a little bit less unpredictable. If the release were somehow to change under the same name, then it would fail cause the SHA would have a different signature.\nBut… how does one get the SHA? A trick is to just leave it blank. Nix will inform you and make a comparison of the expected vs actual signature.\nAdd this in the outputs schema:\nsrc = pkgs.fetchurl { # Remember `rec`! url = \"https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\"; sha256 = \"\"; }; and run nix build in the directory with this flake.nix file.\nsekun@nixos ~/P/g/n/postgrest (feature/postgrest) nix build warning: Git tree '/home/sekun/Projects/gnawex' is dirty warning: found empty hash, assuming 'sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=' error: hash mismatch in fixed-output derivation '/nix/store/mag8ly8f0rlw5dqxj7ir8maa1bqgkyxv-postgrest-v9.0.0-linux-static-x64.tar.xz.drv': specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA= got: sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4= error: 1 dependencies of derivation '/nix/store/yg6adsask3s2sg636m5dwy0c79dadg9g-postgrest-9.0.0.drv' failed to build sekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1] It does fail, as expected. This is how it’ll be if ever the signature were to change. But there it is! It tells us what we specified, and what Nix got. So let’s yoink that and slap it in the schema.\nsrc = pkgs.fetchurl { url = \"https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\"; sha256 = \"sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=\"; }; Now that we have the binary, all that’s left is to install it.\nInstalling Going back to the example in 4:\nstdenv.mkDerivation rec { name = \"studio-link-${version}\"; version = \"21.07.0\"; src = fetchurl { url = \"https://download.studio.link/releases/v${version}-stable/linux/studio-link-standalone-v${version}.tar.gz\"; sha256 = \"sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=\"; }; nativeBuildInputs = [ autoPatchelfHook ]; buildInputs = [ alsaLib openssl zlib pulseaudio ]; sourceRoot = \".\"; installPhase = '' install -m755 -D studio-link-standalone-v${version}$out/bin/studio-link ''; meta = with lib; { homepage = \"https://studio-link.com\"; description = \"Voip transfer\"; platforms = platforms.linux; }; } We can ignore nativeBuildInputs and buildInputs since those are used for declaring what dependencies should be there when building something. In this case, there’s nothing to build because we just got a pre-built binary. Nor do we have to provide any runtime dependencies because it’s a static binary. That leaves sourceRoot, installPhase, and meta left. I tried looking for more information about sourceRoot found some explanations but I was left unsure if I needed it. Let’s leave that out for now. We do need installPhase since we have to send it off to the Nix store. It looks like I can reuse this without much changes.\ninstallPhase = '' install -m755 -D postgrest $out/bin/postgrest ''; I have no idea what install is. And as usual, check the manual/wiki! The manual description tells me it’s how one copies files while setting attributes. -m755 sets the permissions to 755, postgrest is the source, and $out/bin/postgrest is the target. $out is set by Nix, which points to the Nix store with the package’s name for the folder. Alright, cool!\nTime to run nix build again to see if this works.\n…and it doesn’t.\nsekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1] nix build warning: Git tree '/home/sekun/Projects/gnawex' is dirty error: builder for '/nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv' failed with exit code 1; last 3 log lines:  unpacking sources  unpacking source archive /nix/store/644yqp1y3cgw45qfqsbxb013hm4r2zw6-postgrest-v9.0.0-linux-static-x64.tar.xz  unpacker appears to have produced no directories For full logs, run 'nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv'. The error seems to point out that it couldn’t unpack the tar anywhere. Running nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv seems to tell me the same thing.\nAlright alright, let’s take a look at what the manual has to say about sourceRoot:\n After running unpackPhase, the generic builder changes the current directory to the directory created by unpacking the sources. If there are multiple source directories, you should set sourceRoot to the name of the intended directory. Set sourceRoot = “.\"; if you use srcs and control the unpack phase yourself.\n This isn’t really so helpful because I’m not using srcs, nor am I using unpackPhase, nor am I unpacking multiple sources! I am however specifying a remote file as src with fetchurl, which does seem to unpack it. I have no clue what fetchurl does because the manual doesn’t seem to cover it 5. No idea what else to do here so I’ll just follow the suggestion of adding sourceRoot \".\". Run nix build again, and see it finally work!\nHere’s the final flake:\n{ description = \"REST API for any Postgres database\"; inputs = { nixpkgs.url = \"github:NixOS/nixpkgs\"; }; outputs = {self, nixpkgs}: { defaultPackage.x86_64-linux = with import nixpkgs { system = \"x86_64-linux\"; }; stdenv.mkDerivation rec { name = \"postgrest-${version}\"; version = \"9.0.0\"; # https://nixos.wiki/wiki/Packaging/Binaries src = pkgs.fetchurl { url = \"https://github.com/PostgREST/postgrest/releases/download/v${version}/postgrest-v${version}-linux-static-x64.tar.xz\"; sha256 = \"sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=\"; }; sourceRoot = \".\"; installPhase = '' install -m755 -D postgrest $out/bin/postgrest ''; meta = with lib; { homepage = \"https://postgrest.org\"; description = \"REST API for any Postgres database\"; platforms = platforms.linux; }; }; }; } Importing a local flake to another flake Here’s the flake file that needs postgrest:\n{ description = \"An independent MouseHunt marketplace\"; inputs = { nixpkgs.url = \"github:NixOS/nixpkgs\"; masterpkgs.url = \"github:NixOS/nixpkgs/master\"; flake-utils.url = \"github:numtide/flake-utils\"; }; outputs = { self, nixpkgs, masterpkgs, flake-utils }: flake-utils.lib.eachSystem [ \"x86_64-linux\" ] (system: let pkgs = nixpkgs.legacyPackages.${system}; postgrest = postgrestPkg.defaultPackage.${system}; lib = nixpkgs.lib; in { devShell = pkgs.mkShell rec { buildInputs = [ masterpkgs.legacyPackages.${system}.pgadmin4 ]; }; }); }  Oh, you don’t know what GNAWEX 6 is? Well, it’s just an app I’ve been working on for a video game I’ve been playing for nearly 12 years. I’m not addicted, I swear. I’m only doing this to learn PostgreSQL’s cool features!\n Besides using flake-utils to make handling different s more convenient, the flake does look pretty much the same. Now how does one refer to this local postgrest flake in this flake? Fortunately, the wiki 1 has an example in the inputs schema section:\n# local directories (for absolute paths you can omit 'path:') directory-example.url = \"path:/path/to/repo\"; We need to keep path: since we need a relative path since the postgrest flake is in ./nix/postgrest/flake.nix. Add this to the flake file that needs it, in its inputs set:\ninputs = { # ... postgrestPkg.url = \"path:./nix/postgrest\"; }; postgrestPkg can be anything, but I’m naming it postgrestPkg to avoid confusion with the actual postgrest package. Then, for convenience, I added this in the let expression:\npostgrest = postgrestPkg.defaultPackage.${system}; This binds postgres-9-0-0 to postgrest, which I use in devShell’s buildInputs. Here’s the final flake:\n{ description = \"An independent MouseHunt marketplace\"; inputs = { nixpkgs.url = \"github:NixOS/nixpkgs\"; masterpkgs.url = \"github:NixOS/nixpkgs/master\"; postgrestPkg.url = \"path:./nix/postgrest\"; # New! flake-utils.url = \"github:numtide/flake-utils\"; }; # V Add this one. Order matters. outputs = { self, nixpkgs, masterpkgs, postgrestPkg, flake-utils }: flake-utils.lib.eachSystem [ \"x86_64-linux\" ] (system: let pkgs = nixpkgs.legacyPackages.${system}; postgrest = postgrestPkg.defaultPackage.${system}; # For convenience lib = nixpkgs.lib; in { devShell = pkgs.mkShell rec { buildInputs = [ postgrest # A shiny `postgres` package! masterpkgs.legacyPackages.${system}.pgadmin4 ]; }; }); } Now postgrest is available in the shell environment:\ndirenv: loading ~/Projects/gnawex/.envrc direnv: using flake warning: Git tree '/home/sekun/Projects/gnawex' is dirty warning: Git tree '/home/sekun/Projects/gnawex' is dirty direnv: renewed cache direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DETERMINISTIC_BUILD +HOST_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_BUILD_CORES +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_INDENT_MAKE +NIX_LDFLAGS +NIX_STORE +NM +OBJCOPY +OBJDUMP +PYTHONHASHSEED +PYTHONNOUSERSITE +PYTHONPATH +RANLIB +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +_PYTHON_HOST_PLATFORM +_PYTHON_SYSCONFIGDATA_NAME +buildInputs +buildPhase +builder +configureFlags +depsBuildBuild +depsBuildBuildPropagated +depsBuildTarget +depsBuildTargetPropagated +depsHostHost +depsHostHostPropagated +depsTargetTarget +depsTargetTargetPropagated +doCheck +doInstallCheck +dontAddDisableDepTrack +name +nativeBuildInputs +out +outputs +patches +phases +propagatedBuildInputs +propagatedNativeBuildInputs +shell +shellHook +stdenv +strictDeps +system ~PATH ~XDG_DATA_DIRS sekun@nixos ~/P/gnawex (feature/postgrest) postgrest Usage: postgrest [-e|--example] [--dump-config | --dump-schema] FILENAME PostgREST 9.0.0 / create a REST API to an existing Postgres database Available options: -h,--help Show this help text -e,--example Show an example configuration file --dump-config Dump loaded configuration and exit --dump-schema Dump loaded schema as JSON and exit (for debugging, output structure is unstable) FILENAME Path to configuration file (optional with PGRST_ environment variables) To run PostgREST, please pass the FILENAME argument or set PGRST_ environment variables. If you’re wondering how to load the nix shell automatically without running nix develop, look into direnv, and nix-direnv! I’ll probably write about that too since it’s so damn handy that I can’t live without it. It’s like virtualenv on crack.\nConclusion Could’ve been easier if everything was in the manual. But it isn’t so the entire process of figuring it out involved a lot of Google-fu + man + GitHub code search.\nThat’s it from me for now. It’s a relatively basic thing to do in Nix since this is in many leagues easier than building a project with it. Still useful though since there’s a lot of pre-built, static binaries out there.\n  https://nixos.wiki/wiki/Flakes ↩︎\n https://nixos.org/guides/nix-pills/basics-of-language.html#idm140737320525664 ↩︎\n https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#flake-format ↩︎\n https://nixos.wiki/wiki/Packaging/Binaries ↩︎\n https://github.com/NixOS/nix/issues/1489 ↩︎\n https://github.com/gnawex/gnawex ↩︎\n   ","wordCount":"2390","inLanguage":"en","image":"https://blog.sekun.dev/posts/p1-cover.jpg","datePublished":"2021-03-06T04:11:00Z","dateModified":"2021-03-06T04:11:00Z","author":{"@type":"Person","name":"sekun"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.sekun.dev/posts/packaging-prebuilt-binaries-with-nix/"},"publisher":{"@type":"Organization","name":"sekun's blog","logo":{"@type":"ImageObject","url":"https://blog.sekun.dev/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.sekun.dev accesskey=h title="sekun's blog (Alt + H)">sekun's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
<li>
<a href=https://blog.sekun.dev/posts/ title=posts>
<span>posts</span>
</a>
</li>
<li>
<a href=https://blog.sekun.dev/tags/ title=tags>
<span>tags</span>
</a>
</li>
<li>
<a href=https://blog.sekun.dev/archive/ title="search (Alt + /)" accesskey=/>
<span>search</span>
</a>
</li>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Packaging Pre-built Binaries with Nix Flake
</h1>
<div class=post-meta><span title="2021-03-06 04:11:00 +0000 UTC">March 6, 2021</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;sekun&nbsp;|&nbsp;<a href=https://github.com/sekunho/sekun.dev/tree/main/blog/content/posts/packaging-prebuilt-binaries-with-nix.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://blog.sekun.dev/posts/p1-cover.jpg alt="Post cover saying the phrase 'packaging pre-built, static binaries with Nix flake'">
<p>Seemed difficult, but was a smidge easier than expected</p>
</figure><div class=toc>
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#setup aria-label=Setup>Setup</a></li>
<li>
<a href=#fetching-the-binary aria-label="Fetching the binary">Fetching the binary</a></li>
<li>
<a href=#installing aria-label=Installing>Installing</a></li>
<li>
<a href=#importing-a-local-flake-to-another-flake aria-label="Importing a local flake to another flake">Importing a local flake to another flake</a></li>
<li>
<a href=#conclusion aria-label=Conclusion>Conclusion</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>Here&rsquo;s the scenario: You have a nix environment all set up with all the
dependencies you need for working on your next awesome project. All but one.
<code>nixpkgs</code> doesn&rsquo;t have the version you want. Fortunately, there&rsquo;s a static
binary file on their GitHub page. So should you just manually download it
every time you set your project up, or should you write a Nix package that
builds it from source?</p>
<p>None of em! I don&rsquo;t want to maintain any bash scripts to do that. I just want
to load up the Nix environment, and start.</p>
<p>That was pretty much what I ran into today, I wanted to have
<a href=https://postgrest.org><code>postgrest</code></a> in my Nix environment so I hopped on
<code>nixpkgs</code> search, only to find that the existing versions are quite old, as
well as having to build the project from source. Which I didn&rsquo;t want to do due
to my limited LTE bandwidth. Why should I? <code>postgrest</code> has pre-built, <em>static</em>
binaries in its GitHub releases page. Is there any way I can make use of that
instead? And that&rsquo;s what I set off to do today.</p>
<p><em>tl;dr: Binaries are built, me copy. Me save mobile data. Happy.</em></p>
<blockquote>
<p>Disclaimer: I&rsquo;m a Nix newbie.</p>
</blockquote>
<h1 id=setup>Setup<a hidden class=anchor aria-hidden=true href=#setup>#</a></h1>
<p>I need to import the <code>postgrest</code> flake to an existing flake of another project.
The project&rsquo;s directory has a <code>nix</code> folder for all the packages that don&rsquo;t
exist in <code>nixpkgs</code>, like so:</p>
<pre tabindex=0><code>nix
└── postgrest
    ├── flake.lock
    └── flake.nix
</code></pre><p>The <code>flake.lock</code> gets automatically generated by Nix when it finds out that it
doesn&rsquo;t exist yet when running <code>nix build</code>; no need to create that. Here&rsquo;s the
starting <code>flake.nix</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{
  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;REST API for any Postgres database&#34;</span>;

  inputs <span style=color:#f92672>=</span> {
    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs&#34;</span>;
  };

  outputs <span style=color:#f92672>=</span> {self<span style=color:#f92672>,</span> nixpkgs}: { };
}
</code></pre></div><p>A basic flake file has a set of inputs and outputs. The output here will be the
<code>postgrest</code> package.</p>
<p>Time to throw the binary in Nix.</p>
<p>I have no idea how to build things in flakes, so consulting the wiki is pretty
much a requirement <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>! It covers things like how to enable flakes, and I
won&rsquo;t bother covering because I&rsquo;ll only make a worse version of it.</p>
<p>It tells me about both the <code>inputs</code> and <code>outputs</code> schema. But because I only
need <code>nixpkgs</code> for this one, there&rsquo;s not much else for me to add to the
<code>inputs</code>.</p>
<p>Here&rsquo;s the output schema:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{ self<span style=color:#f92672>,</span> <span style=color:#f92672>...</span> }<span style=color:#f92672>@</span>inputs:
{
  <span style=color:#75715e># Executed by `nix flake check`</span>
  checks<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;name&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Executed by `nix build .#&lt;name&gt;`</span>
  packages<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;name&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Executed by `nix build .`</span>
  defaultPackage<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Executed by `nix run .#&lt;name&gt;`</span>
  apps<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;name&gt;&#34;</span> <span style=color:#f92672>=</span> {
    type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;app&#34;</span>;
    program <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;store-path&gt;&#34;</span>;
  };
  <span style=color:#75715e># Executed by `nix run . -- &lt;args?&gt;`</span>
  defaultApp<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span> <span style=color:#f92672>=</span> { type <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;app&#34;</span>; program <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;...&#34;</span>; };
  
  <span style=color:#75715e># Used for nixpkgs packages, also accessible via `nix build .#&lt;name&gt;`</span>
  legacyPackages<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;name&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Default overlay, consumed by other flakes</span>
  overlay <span style=color:#f92672>=</span> final: prev: { };
  <span style=color:#75715e># Same idea as overlay but a list or attrset of them.</span>
  overlays <span style=color:#f92672>=</span> {};
  <span style=color:#75715e># Default module, consumed by other flakes</span>
  nixosModule <span style=color:#f92672>=</span> { config }: { options <span style=color:#f92672>=</span> {}; config <span style=color:#f92672>=</span> {}; };
  <span style=color:#75715e># Same idea as nixosModule but a list or attrset of them.</span>
  nixosModules <span style=color:#f92672>=</span> {};
  <span style=color:#75715e># Used with `nixos-rebuild --flake .#&lt;hostname&gt;`</span>
  <span style=color:#75715e># nixosConfigurations.&#34;&lt;hostname&gt;&#34;.config.system.build.toplevel must be a derivation</span>
  nixosConfigurations<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;hostname&gt;&#34;</span> <span style=color:#f92672>=</span> {};
  <span style=color:#75715e># Used by `nix develop`</span>
  devShell<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Used by `nix develop .#&lt;name&gt;`</span>
  devShells<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;name&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Hydra build jobs</span>
  hydraJobs<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;attr&gt;&#34;</span><span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;system&gt;&#34;</span> <span style=color:#f92672>=</span> derivation;
  <span style=color:#75715e># Used by `nix flake init -t &lt;flake&gt;`</span>
  defaultTemplate <span style=color:#f92672>=</span> {
    path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;store-path&gt;&#34;</span>;
    description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;template description goes here?&#34;</span>;
  };
  <span style=color:#75715e># Used by `nix flake init -t &lt;flake&gt;#&lt;name&gt;`</span>
  templates<span style=color:#f92672>.</span><span style=color:#e6db74>&#34;&lt;name&gt;&#34;</span> <span style=color:#f92672>=</span> { path <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&lt;store-path&gt;&#34;</span>; description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>; };
}
</code></pre></div><p>That&rsquo;s a lot.</p>
<p><code>outputs</code> is a lambda with a set as its argument. Since nix functions can only
have one argument, putting the stuff you need in a set is how you get around
that restriction. <code>{self, ...}</code> is some form of pattern matching the fields
in a set, and <code>@inputs</code> binds the set to <code>input</code>. Cool. The latter isn&rsquo;t that
useful to me in this scenario though, so I&rsquo;ll omit that. It seems that in every
flake <code>outputs</code>, <code>self</code> must be there. I don&rsquo;t understand what <code>self</code> is, but
I&rsquo;ll leave that for another time.</p>
<p>With the schema, there are two fields that <em>seem</em> important: <code>packages</code>, and
<code>defaultPackage</code>. <code>packages</code> would be useful if I wanted to have multiple
versions of <code>postgrest</code> available for me to use like <code>postgres-8-0-0</code> and
<code>postgrest-9-0-0</code>, but I don&rsquo;t! I only need the latest version, which is <code>9.0.0</code>
at the time of writing. So we can ignore that, and I&rsquo;ll use <code>defaultPackage</code>
instead.</p>
<p>Here&rsquo;s what we have so far:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{
  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;REST API for any Postgres database&#34;</span>;

  inputs <span style=color:#f92672>=</span> {
    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs&#34;</span>;
  };

  outputs <span style=color:#f92672>=</span> {self<span style=color:#f92672>,</span> nixpkgs}: {
    defaultPackage<span style=color:#f92672>.</span>x86_64-linux <span style=color:#f92672>=</span>
      <span style=color:#66d9ef>with</span> <span style=color:#f92672>import</span> nixpkgs { system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>; };

      stdenv<span style=color:#f92672>.</span>mkDerivation <span style=color:#66d9ef>rec</span> {
        name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;postgrest-</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>;

        version <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;9.0.0&#34;</span>;

        <span style=color:#75715e># I still lack stuff here!</span>
      };
  };
}
</code></pre></div><p><code>with import nixpkgs {system = "x86_64-linux"};</code> spares me from having to
qualify everything like <code>nixpkgs.system."x86_64".stdenv.mkDerivation</code> which
is handy <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. This brings <code>stdenv</code> into scope, and has <code>mkDerivation</code> which, from
the name, makes a <code>derivation</code>; something I need for <code>defaultPackage.&lt;system></code>.
Unfortunately, I couldn&rsquo;t find any official documentation for <code>mkDerivation</code>
that species every single field usable in it. Maybe it exists and that I just
suck at Googling. That is definitely possible. There are some examples <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>,
especially in the wild.</p>
<p><code>rec</code> allows me to refer to the set&rsquo;s own fields within it. I&rsquo;m using the
field <code>version</code> and interpolated it in <code>name</code>!</p>
<p>Alright that&rsquo;s it for the setup. Time to fetch the binary.</p>
<h1 id=fetching-the-binary>Fetching the binary<a hidden class=anchor aria-hidden=true href=#fetching-the-binary>#</a></h1>
<p>The wiki has an example for fetching stuff from a URL, and using it in
<code>mkDerivation</code> <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>src <span style=color:#960050;background-color:#1e0010>=</span> fetchurl {
  url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://download.studio.link/releases/v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>-stable/linux/studio-link-standalone-v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>.tar.gz&#34;</span>;
  sha256 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=&#34;</span>;
};
</code></pre></div><p>So it looks like I need two things, a <code>url</code> which can be a <code>tar</code> file, and a
<code>sha256</code>. The <code>sha256</code> field is used to make something impure a little bit
less unpredictable. If the release were somehow to change under the same name,
then it would fail cause the SHA would have a different signature.</p>
<p>But&mldr; how does one get the SHA? A trick is to just leave it blank. Nix will
inform you and make a comparison of the expected vs actual signature.</p>
<p>Add this in the <code>outputs</code> schema:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>src <span style=color:#960050;background-color:#1e0010>=</span> pkgs<span style=color:#f92672>.</span>fetchurl {
  <span style=color:#75715e># Remember `rec`!</span>
  url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://github.com/PostgREST/postgrest/releases/download/v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>/postgrest-v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>-linux-static-x64.tar.xz&#34;</span>;
  sha256 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
};
</code></pre></div><p>and run <code>nix build</code> in the directory with this <code>flake.nix</code> file.</p>
<pre tabindex=0><code>sekun@nixos ~/P/g/n/postgrest (feature/postgrest)&gt; nix build 
warning: Git tree '/home/sekun/Projects/gnawex' is dirty
warning: found empty hash, assuming 'sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA='
error: hash mismatch in fixed-output derivation '/nix/store/mag8ly8f0rlw5dqxj7ir8maa1bqgkyxv-postgrest-v9.0.0-linux-static-x64.tar.xz.drv':
         specified: sha256-AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
            got:    sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=
error: 1 dependencies of derivation '/nix/store/yg6adsask3s2sg636m5dwy0c79dadg9g-postgrest-9.0.0.drv' failed to build
sekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1]&gt; 
</code></pre><p>It does fail, as expected. This is how it&rsquo;ll be if ever the signature
were to change. But there it is! It tells us what we specified, and what Nix
got. So let&rsquo;s yoink that and slap it in the schema.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>src <span style=color:#960050;background-color:#1e0010>=</span> pkgs<span style=color:#f92672>.</span>fetchurl {
  url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://github.com/PostgREST/postgrest/releases/download/v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>/postgrest-v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>-linux-static-x64.tar.xz&#34;</span>;
  sha256 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=&#34;</span>;
};
</code></pre></div><p>Now that we have the binary, all that&rsquo;s left is to install it.</p>
<h1 id=installing>Installing<a hidden class=anchor aria-hidden=true href=#installing>#</a></h1>
<p>Going back to the example in <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>stdenv<span style=color:#f92672>.</span>mkDerivation <span style=color:#66d9ef>rec</span> {
  name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;studio-link-</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>;

  version <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;21.07.0&#34;</span>;

  src <span style=color:#f92672>=</span> fetchurl {
    url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://download.studio.link/releases/v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>-stable/linux/studio-link-standalone-v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>.tar.gz&#34;</span>;
    sha256 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sha256-4CkijAlenhht8tyk3nBULaBPE0GBf6DVII699/RmmWI=&#34;</span>;
  };

  nativeBuildInputs <span style=color:#f92672>=</span> [
    autoPatchelfHook
  ];

  buildInputs <span style=color:#f92672>=</span> [
    alsaLib
    openssl
    zlib
    pulseaudio
  ];

  sourceRoot <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.&#34;</span>;

  installPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span><span style=color:#e6db74>    install -m755 -D studio-link-standalone-v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74> $out/bin/studio-link
</span><span style=color:#e6db74>  &#39;&#39;</span>;

  meta <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> lib; {
    homepage <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://studio-link.com&#34;</span>;
    description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Voip transfer&#34;</span>;
    platforms <span style=color:#f92672>=</span> platforms<span style=color:#f92672>.</span>linux;
  };
}
</code></pre></div><p>We can ignore <code>nativeBuildInputs</code> and <code>buildInputs</code> since those are used for
declaring what dependencies should be there when building something. In this
case, there&rsquo;s nothing to build because we just got a pre-built binary. Nor do
we have to provide any runtime dependencies because it&rsquo;s a static binary.
That leaves <code>sourceRoot</code>, <code>installPhase</code>, and <code>meta</code> left. I tried looking for
more information about <code>sourceRoot</code> found some explanations but I was left
unsure if I needed it. Let&rsquo;s leave that out for now. We do need <code>installPhase</code>
since we have to send it off to the Nix store. It looks like I can reuse this
without much changes.</p>
<pre tabindex=0><code>installPhase = ''
install -m755 -D postgrest $out/bin/postgrest
'';
</code></pre><p>I have no idea what <code>install</code> is. And as usual, check the manual/wiki! The
manual description tells me it&rsquo;s how one copies files while setting attributes.
<code>-m755</code> sets the permissions to <code>755</code>, <code>postgrest</code> is the source, and
<code>$out/bin/postgrest</code> is the target. <code>$out</code> is set by Nix, which points to the
Nix store with the package&rsquo;s name for the folder. Alright, cool!</p>
<p>Time to run <code>nix build</code> again to see if this works.</p>
<p>&mldr;and it doesn&rsquo;t.</p>
<pre tabindex=0><code>sekun@nixos ~/P/g/n/postgrest (feature/postgrest) [1]&gt; nix build
warning: Git tree '/home/sekun/Projects/gnawex' is dirty
error: builder for '/nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv' failed with exit code 1;
       last 3 log lines:
       &gt; unpacking sources
       &gt; unpacking source archive /nix/store/644yqp1y3cgw45qfqsbxb013hm4r2zw6-postgrest-v9.0.0-linux-static-x64.tar.xz
       &gt; unpacker appears to have produced no directories
       For full logs, run 'nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv'.
</code></pre><p>The error seems to point out that it couldn&rsquo;t unpack the <code>tar</code> anywhere.
Running <code>nix log /nix/store/jsxk8q3handkprh5ma102v8y1dig9k77-postgrest-9.0.0.drv</code>
seems to tell me the same thing.</p>
<p>Alright alright, let&rsquo;s take a look at what the manual has to say about
<code>sourceRoot</code>:</p>
<blockquote>
<p>After running unpackPhase, the generic builder changes the current directory
to the directory created by unpacking the sources. If there are multiple
source directories, you should set sourceRoot to the name of the intended
directory. Set sourceRoot = &ldquo;."; if you use srcs and control the unpack
phase yourself.</p>
</blockquote>
<p>This isn&rsquo;t really so helpful because I&rsquo;m not using <code>srcs</code>, nor am I using
<code>unpackPhase</code>, nor am I unpacking multiple sources! I am however specifying a
remote file as <code>src</code> with <code>fetchurl</code>, which does seem to unpack it. I have
no clue what <code>fetchurl</code> does because the manual doesn&rsquo;t seem to cover it <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>.
No idea what else to do here so I&rsquo;ll just follow the suggestion of adding
<code>sourceRoot "."</code>. Run <code>nix build</code> again, and see it <em>finally</em> work!</p>
<p>Here&rsquo;s the final flake:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{
  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;REST API for any Postgres database&#34;</span>;

  inputs <span style=color:#f92672>=</span> {
    nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs&#34;</span>;
  };

  outputs <span style=color:#f92672>=</span> {self<span style=color:#f92672>,</span> nixpkgs}: {
    defaultPackage<span style=color:#f92672>.</span>x86_64-linux <span style=color:#f92672>=</span>
      <span style=color:#66d9ef>with</span> <span style=color:#f92672>import</span> nixpkgs { system <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;x86_64-linux&#34;</span>; };

      stdenv<span style=color:#f92672>.</span>mkDerivation <span style=color:#66d9ef>rec</span> {
        name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;postgrest-</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>;

        version <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;9.0.0&#34;</span>;

        <span style=color:#75715e># https://nixos.wiki/wiki/Packaging/Binaries</span>
        src <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>fetchurl {
          url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://github.com/PostgREST/postgrest/releases/download/v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>/postgrest-v</span><span style=color:#e6db74>${</span>version<span style=color:#e6db74>}</span><span style=color:#e6db74>-linux-static-x64.tar.xz&#34;</span>;
          sha256 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;sha256-6kgh6heVV7qNcNzcXTiqbVyhfsSV9u5/S3skto6Uzz4=&#34;</span>;
        };

        sourceRoot <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;.&#34;</span>;

        installPhase <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;
</span><span style=color:#e6db74>        install -m755 -D postgrest $out/bin/postgrest
</span><span style=color:#e6db74>        &#39;&#39;</span>;

        meta <span style=color:#f92672>=</span> <span style=color:#66d9ef>with</span> lib; {
          homepage <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;https://postgrest.org&#34;</span>;
          description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;REST API for any Postgres database&#34;</span>;
          platforms <span style=color:#f92672>=</span> platforms<span style=color:#f92672>.</span>linux;
        };
      };
  };
}
</code></pre></div><h1 id=importing-a-local-flake-to-another-flake>Importing a local flake to another flake<a hidden class=anchor aria-hidden=true href=#importing-a-local-flake-to-another-flake>#</a></h1>
<p>Here&rsquo;s the flake file that needs <code>postgrest</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{
  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;An independent MouseHunt marketplace&#34;</span>;

  inputs <span style=color:#f92672>=</span> {
     nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs&#34;</span>;
     masterpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs/master&#34;</span>;
     flake-utils<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:numtide/flake-utils&#34;</span>;
  };

  outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> masterpkgs<span style=color:#f92672>,</span> flake-utils }:
    flake-utils<span style=color:#f92672>.</span>lib<span style=color:#f92672>.</span>eachSystem [ <span style=color:#e6db74>&#34;x86_64-linux&#34;</span> ] (system:
      <span style=color:#66d9ef>let</span> pkgs <span style=color:#f92672>=</span> nixpkgs<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>;
          postgrest <span style=color:#f92672>=</span> postgrestPkg<span style=color:#f92672>.</span>defaultPackage<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>;
          lib <span style=color:#f92672>=</span>  nixpkgs<span style=color:#f92672>.</span>lib;

      <span style=color:#66d9ef>in</span> {
        devShell <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>mkShell <span style=color:#66d9ef>rec</span> {
          buildInputs <span style=color:#f92672>=</span> [
            masterpkgs<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>pgadmin4
          ];
        };
      });
}
</code></pre></div><blockquote>
<p>Oh, you don&rsquo;t know what GNAWEX <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> is? Well, it&rsquo;s just an app I&rsquo;ve been working
on for a video game I&rsquo;ve been playing for nearly 12 years. I&rsquo;m not addicted,
I swear. I&rsquo;m only doing this to learn PostgreSQL&rsquo;s cool features!</p>
</blockquote>
<p>Besides using <code>flake-utils</code> to make handling different <code>&lt;system></code>s more
convenient, the flake does look pretty much the same. Now how does one refer to
this local <code>postgrest</code> flake in <em>this</em> flake? Fortunately, the wiki <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> has an
example in the <code>inputs</code> schema section:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix><span style=color:#75715e># local directories (for absolute paths you can omit &#39;path:&#39;)</span>
directory-example<span style=color:#f92672>.</span>url <span style=color:#960050;background-color:#1e0010>=</span> <span style=color:#e6db74>&#34;path:/path/to/repo&#34;</span>;
</code></pre></div><p>We need to keep <code>path:</code> since we need a relative path since the <code>postgrest</code>
flake is in <code>./nix/postgrest/flake.nix</code>. Add this to the flake file that needs
it, in its <code>inputs</code> set:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>inputs <span style=color:#960050;background-color:#1e0010>=</span> {
  <span style=color:#75715e># ...</span>
  postgrestPkg<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;path:./nix/postgrest&#34;</span>;
};
</code></pre></div><p><code>postgrestPkg</code> can be anything, but I&rsquo;m naming it <code>postgrestPkg</code> to avoid
confusion with the actual <code>postgrest</code> package. Then, for convenience, I added
this in the <code>let</code> expression:</p>
<pre tabindex=0><code>postgrest = postgrestPkg.defaultPackage.${system};
</code></pre><p>This binds <code>postgres-9-0-0</code> to <code>postgrest</code>, which I use in <code>devShell</code>&rsquo;s
<code>buildInputs</code>. Here&rsquo;s the final <code>flake</code>:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-nix data-lang=nix>{
  description <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;An independent MouseHunt marketplace&#34;</span>;

  inputs <span style=color:#f92672>=</span> {
     nixpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs&#34;</span>;
     masterpkgs<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:NixOS/nixpkgs/master&#34;</span>;
     postgrestPkg<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;path:./nix/postgrest&#34;</span>; <span style=color:#75715e># New!</span>
     flake-utils<span style=color:#f92672>.</span>url <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;github:numtide/flake-utils&#34;</span>;
  };

                                         <span style=color:#75715e># V Add this one. Order matters.</span>
  outputs <span style=color:#f92672>=</span> { self<span style=color:#f92672>,</span> nixpkgs<span style=color:#f92672>,</span> masterpkgs<span style=color:#f92672>,</span> postgrestPkg<span style=color:#f92672>,</span> flake-utils }:
    flake-utils<span style=color:#f92672>.</span>lib<span style=color:#f92672>.</span>eachSystem [ <span style=color:#e6db74>&#34;x86_64-linux&#34;</span> ] (system:
      <span style=color:#66d9ef>let</span> pkgs <span style=color:#f92672>=</span> nixpkgs<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>;
          postgrest <span style=color:#f92672>=</span> postgrestPkg<span style=color:#f92672>.</span>defaultPackage<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span>; <span style=color:#75715e># For convenience</span>
          lib <span style=color:#f92672>=</span>  nixpkgs<span style=color:#f92672>.</span>lib;

      <span style=color:#66d9ef>in</span> {
        devShell <span style=color:#f92672>=</span> pkgs<span style=color:#f92672>.</span>mkShell <span style=color:#66d9ef>rec</span> {
          buildInputs <span style=color:#f92672>=</span> [
            postgrest <span style=color:#75715e># A shiny `postgres` package!</span>
            masterpkgs<span style=color:#f92672>.</span>legacyPackages<span style=color:#f92672>.</span><span style=color:#e6db74>${</span>system<span style=color:#e6db74>}</span><span style=color:#f92672>.</span>pgadmin4
          ];
        };
      });
}
</code></pre></div><p>Now <code>postgrest</code> is available in the shell environment:</p>
<pre tabindex=0><code>direnv: loading ~/Projects/gnawex/.envrc
direnv: using flake
warning: Git tree '/home/sekun/Projects/gnawex' is dirty
warning: Git tree '/home/sekun/Projects/gnawex' is dirty
direnv: renewed cache
direnv: export +AR +AS +CC +CONFIG_SHELL +CXX +DETERMINISTIC_BUILD +HOST_PATH +IN_NIX_SHELL +LD +NIX_BINTOOLS +NIX_BINTOOLS_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_BUILD_CORES +NIX_CC +NIX_CC_WRAPPER_TARGET_HOST_x86_64_unknown_linux_gnu +NIX_CFLAGS_COMPILE +NIX_ENFORCE_NO_NATIVE +NIX_HARDENING_ENABLE +NIX_INDENT_MAKE +NIX_LDFLAGS +NIX_STORE +NM +OBJCOPY +OBJDUMP +PYTHONHASHSEED +PYTHONNOUSERSITE +PYTHONPATH +RANLIB +READELF +SIZE +SOURCE_DATE_EPOCH +STRINGS +STRIP +_PYTHON_HOST_PLATFORM +_PYTHON_SYSCONFIGDATA_NAME +buildInputs +buildPhase +builder +configureFlags +depsBuildBuild +depsBuildBuildPropagated +depsBuildTarget +depsBuildTargetPropagated +depsHostHost +depsHostHostPropagated +depsTargetTarget +depsTargetTargetPropagated +doCheck +doInstallCheck +dontAddDisableDepTrack +name +nativeBuildInputs +out +outputs +patches +phases +propagatedBuildInputs +propagatedNativeBuildInputs +shell +shellHook +stdenv +strictDeps +system ~PATH ~XDG_DATA_DIRS
sekun@nixos ~/P/gnawex (feature/postgrest)&gt; postgrest
Usage: postgrest [-e|--example] [--dump-config | --dump-schema] FILENAME
  PostgREST 9.0.0 / create a REST API to an existing Postgres database

Available options:
  -h,--help                Show this help text
  -e,--example             Show an example configuration file
  --dump-config            Dump loaded configuration and exit
  --dump-schema            Dump loaded schema as JSON and exit (for debugging,
                           output structure is unstable)
  FILENAME                 Path to configuration file (optional with PGRST_
                           environment variables)

To run PostgREST, please pass the FILENAME argument or set PGRST_ environment
variables.
</code></pre><p>If you&rsquo;re wondering how to load the nix shell automatically without running
<code>nix develop</code>, look into <code>direnv</code>, and <code>nix-direnv</code>! I&rsquo;ll probably write about
that too since it&rsquo;s so damn handy that I can&rsquo;t live without it. It&rsquo;s like
<code>virtualenv</code> on crack.</p>
<h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1>
<p>Could&rsquo;ve been easier if everything was in the manual. But it isn&rsquo;t so the
entire process of figuring it out involved a lot of Google-fu + <code>man</code> +
GitHub code search.</p>
<p>That&rsquo;s it from me for now. It&rsquo;s a relatively basic thing to do in Nix
since this is in many leagues easier than building a project with it. Still
useful though since there&rsquo;s a <em>lot</em> of pre-built, static binaries out there.</p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=https://nixos.wiki/wiki/Flakes>https://nixos.wiki/wiki/Flakes</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p><a href=https://nixos.org/guides/nix-pills/basics-of-language.html#idm140737320525664>https://nixos.org/guides/nix-pills/basics-of-language.html#idm140737320525664</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p><a href=https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#flake-format>https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-flake.html#flake-format</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p><a href=https://nixos.wiki/wiki/Packaging/Binaries>https://nixos.wiki/wiki/Packaging/Binaries</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p><a href=https://github.com/NixOS/nix/issues/1489>https://github.com/NixOS/nix/issues/1489</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p><a href=https://github.com/gnawex/gnawex>https://github.com/gnawex/gnawex</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://blog.sekun.dev/tags/nix/>nix</a></li>
<li><a href=https://blog.sekun.dev/tags/postgrest/>postgrest</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.sekun.dev>sekun's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
<script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script>
</body>
</html>